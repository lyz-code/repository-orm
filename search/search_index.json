{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Repository ORM","text":"<p>Library to persist Pydantic models into different storage backends following the repository pattern.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install repository-orm\n</code></pre>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<pre><code>from repository_orm import Entity, load_repository\n\n\nclass Author(Entity):\n    first_name: str\n    last_name: str\n    country: str\n\n\nrepo = load_repository()\n\nauthor = Author(first_name=\"Brandon\", last_name=\"Sanderson\", country=\"US\")\n\n# Add entities\nrepo.add(author)\nrepo.commit()\n\n# Retrieve entities by their ID\nbrandon = repo.get(0, Author)\nassert brandon == author\n\n# Search entities\nbrandon = repo.search({\"first_name\": \"Brandon\"}, Author)[0]\nassert brandon == author\n\n# Delete entities\nrepo.delete(brandon)\nrepo.commit()\nassert len(repo.all(Author)) == 0\n\n# Close the connection\nrepo.close()\n</code></pre>"},{"location":"#repository-pattern-theory","title":"Repository pattern theory","text":"<p>The repository pattern is an abstraction over persistent storage, allowing you to decouple the model layer from the data layer. It hides the boring details of data access by pretending that all of our data is in memory.</p> <p>It has the following advantages:</p> <ul> <li>Give a simple interface, which you control, between persistent storage and our   domain model.</li> <li>It's easy to make a fake version of the repository for unit testing, or to   swap out different storage solutions, because the model is fully decoupled   from the infrastructure.</li> <li>Writing the domain model before thinking about persistence helps focus on the   problem at hand. If we need to change our approach, we can do that in our   model, without needing to worry about foreign keys or migrations until later.</li> <li>Our database schema is simple because we have complete control over how we map   our object to tables.</li> <li>Speeds up and makes more clean the business logic tests.</li> <li>It's easy to implement.</li> </ul> <p>But the following disadvantages:</p> <ul> <li>An ORM already buys you some decoupling. Changing foreign keys might be hard,   but it should be pretty easy to swap between MySQL and PostgreSQL if you ever   need to.</li> <li>Maintaining ORM mappings by hand requires extra work and extra code.</li> <li>An extra layer of abstraction is introduced, and although we may hope it will   reduce complexity overall, it does add complexity locally. Furthermore it adds   the WTF factor for Python programmers who've never seen this pattern before.</li> </ul> <p>repository-orm aims to mitigate the last ones by:</p> <ul> <li>Supplying classes that already have the common operations for different   storage solutions.</li> <li>Supplying test classes and fixtures so extending the provided repositories is   easy.</li> </ul>"},{"location":"#repositories","title":"Repositories","text":"<p>There are two kinds of repositories:</p> <ul> <li>Data repositories: Give a common interface to store the   models in databases.</li> <li>File repositories: Give a common interface to store   computer file contents.</li> </ul>"},{"location":"#projects-using-repository-orm","title":"Projects using <code>repository-orm</code>","text":"<p>If you want to see the library being used in a simple project, check pynbox code. Other projects using <code>repository-orm</code> are:</p> <ul> <li>clinv: A DevSecOps command line asset   inventory tool.</li> <li>pydo: A free software command line task   manager built in Python.</li> </ul> <p>If you use the library and want to be listed here, open an issue.</p>"},{"location":"#references","title":"References","text":"<p>As most open sourced programs, <code>repository-orm</code> is standing on the shoulders of giants, namely:</p> <ul> <li>pydantic : Used for the   Entities definition.</li> <li>DeepDiff : Used to search strings in   complex objects in the FakeRepository.</li> <li>TinyDB : Used to   interact with the NoSQL database in the   TinyDBRepository</li> <li>Pypika : Used to build the SQL   queries in the PypikaRepository.</li> <li>Yoyo : Used to manage the schema   changes of the PypikaRepository.</li> <li>Pytest : Testing framework, enhanced by   the awesome pytest-cases   library that made the parametrization of the tests a lovely experience.</li> <li>Mypy : Python static type checker.</li> <li>Flakeheaven : Python linter with   lots of checks.</li> <li>Black : Python formatter to keep a   nice style without effort.</li> <li>Autoimport : Python formatter to   automatically fix wrong import statements.</li> <li>isort : Python formatter to order   the import statements.</li> <li>PDM : Command line tool to manage the dependencies.</li> <li>Mkdocs : To build this documentation site, with the   Material theme.</li> <li>Safety : To check the installed   dependencies for known security vulnerabilities.</li> <li>Bandit : To finds common security   issues in Python code.</li> <li>Yamlfix : YAML fixer.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>For guidance on setting up a development environment, and how to make a contribution to repository-orm, see Contributing to repository-orm.</p>"},{"location":"#donations","title":"Donations","text":"<p> or </p> <p>If you are using some of my open-source tools, have enjoyed them, and want to say \"thanks\", this is a very strong way to do it.</p> <p>If your product/company depends on these tools, you can sponsor me to ensure I keep happily maintaining them.</p> <p>If these tools are helping you save money, time, effort, or frustrations; or they are helping you make money, be more productive, efficient, secure, enjoy a bit more your work, or get your product ready faster, this is a great way to show your appreciation. Thanks for that!</p> <p>And by sponsoring me, you are helping make these tools, that already help you, sustainable and healthy.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>So you've started using <code>repository-orm</code> and want to show your gratitude to the project, depending on your programming skills there are different ways to do so.</p>"},{"location":"contributing/#i-dont-know-how-to-program","title":"I don't know how to program","text":"<p>There are several ways you can contribute:</p> <ul> <li>Open an issue if you encounter     any bug or to let us know if you want a new feature to be implemented.</li> <li>Spread the word about the program.</li> <li>Review the documentation and try to improve     it.</li> </ul>"},{"location":"contributing/#i-know-how-to-program-in-python","title":"I know how to program in Python","text":"<p>If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones, check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues, as they are expected to be easier to get into the project.</p> <p>We develop the program with TDD, so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it.</p> <p>We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing:</p> <ul> <li>If you want to develop a new feature, explain how you'd like to do it in the related issue.</li> <li>If you don't know how to test your code, do the pull request without the tests     and we'll try to do them for you.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"import repository_orm.version; print(repository_orm.version.version_info())\"\n</code></pre> <p>or if you have <code>make</code> installed, you can use <code>make version</code>.</p> <p>Please try to always include the above unless you're unable to install <code>repository-orm</code> or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>repository-orm is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p>"},{"location":"contributing/#development-facilities","title":"Development facilities","text":"<p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally.</p> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p> <p>You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed.</p> <ul> <li> <p>Clone your fork and go into the repository directory:</p> <pre><code>git clone git@github.com:&lt;your username&gt;/repository-orm.git\ncd repository-orm\n</code></pre> </li> <li> <p>Set up the virtualenv for running tests:</p> <pre><code>virtualenv -p `which python3.7` env\nsource env/bin/activate\n</code></pre> </li> <li> <p>Install repository-orm, dependencies and configure the     pre-commits:</p> <pre><code>make install\n</code></pre> </li> <li> <p>Checkout a new branch and make your changes:</p> <pre><code>git checkout -b my-new-feature-branch\n</code></pre> </li> <li> <p>Fix formatting and imports: repository-orm uses     black to enforce formatting and     isort to fix imports.</p> <pre><code>make format\n</code></pre> </li> <li> <p>Run tests and linting:</p> <pre><code>make\n</code></pre> <p>There are more sub-commands in Makefile like <code>test-code</code>, <code>test-examples</code>, <code>mypy</code> or <code>security</code> which you might want to use, but generally <code>make</code> should be all you need.</p> <p>If you need to pass specific arguments to pytest use the <code>ARGS</code> variable, for example <code>make test ARGs='-k test_markdownlint_passes'</code>.</p> </li> <li> <p>Build documentation: If you have changed the documentation, make sure it     builds the static site. Once built it will serve the documentation at     <code>localhost:8000</code>:</p> <pre><code>make docs\n</code></pre> </li> <li> <p>Commit, push, and create your pull request.</p> </li> <li> <p>Make a new release: To generate the changelog of the new changes, build the     package, upload to pypi and clean the build files use <code>make bump</code>.</p> </li> </ul> <p>We'd love you to contribute to repository-orm!</p>"},{"location":"fake_repository/","title":"FakeRepository","text":"<p>The <code>FakeRepository</code> is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development.</p> <p>It stores the persisted Entities in the <code>entities</code> object attribute in a dictionary where the keys are the Entity class and the values are list of that Entity objects. When you try to make changes to the repository, the actual <code>entities</code> dictionary is copied to the <code>new_entities</code> attribute. The changes are made on that new attribute and once you use the <code>commit</code> method, they get copied back to the <code>entities</code> attribute.</p> <p>Load it with:</p> <pre><code>from repository_orm import load_repository\n\nrepo = load_repository()\n</code></pre>"},{"location":"fake_repository/#features","title":"Features","text":"<p>Follow the overview example to see how to use each method.</p> <code>add</code> Appends the <code>Entity</code> object to the <code>new_entities</code> attribute. <code>delete</code> Deletes the <code>Entity</code> object from the <code>new_entities</code> attribute. <code>get</code> Obtain an <code>Entity</code> from the <code>entities</code> attribute by it's ID. <code>commit</code> Persist the changes of <code>new_entities</code> into <code>entities</code>, clearing up <code>new_entities</code> afterwards. <code>all</code> Obtain all the entities of type <code>Entity</code> from the <code>entities</code> attribute. <code>search</code> <p>Obtain the entities whose attributes match one or multiple conditions.</p> <p>We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for.</p> <code>apply_migrations</code> <p>Run the migrations of the repository schema.</p> <p>As the fake repository doesn't have any schema this method does nothing.</p>"},{"location":"fake_repository/#simulating-errors","title":"Simulating errors","text":""},{"location":"fake_repository/#connectionerror","title":"ConnectionError","text":"<p>To simulate a connection error to the database, initialize the object with the <code>wrong_database_url</code> string.</p>"},{"location":"file_repositories/","title":"File Repositories","text":"<p>File repositories give a common interface to store computer file contents.</p> <p>They only persist the content of File objects into the different backends. The metadata however is not stored, so you'll need to use a data repository for that.</p>"},{"location":"file_repositories/#a-simple-example","title":"A Simple Example","text":"<pre><code>import os\n\nfrom repository_orm import File, load_file_repository\n\nrepo = load_file_repository(\"local:/tmp/file_data\")\n\nfile_ = File(path=\"test.txt\")\nfile_._content = \"File content\"\n\n# Save content in the repository\n\nfile_ = repo.save(file_)\nassert file_.path == \"/tmp/file_data/test.txt\"\nassert os.path.isfile(file_.path)\n\n# Load the content from the repository\nfile_ = File(path=\"test.txt\")\nfile_ = repo.load(file_)\nassert file_.content == \"File content\"\n\n# Remove the file content from the repository\nrepo.delete(file_)\nassert not os.path.isfile(\"/tmp/file_data/test.txt\") # noqa\n</code></pre>"},{"location":"file_repositories/#usage","title":"Usage","text":"<p>The different repositories share the next operations:</p> <code>load</code> Load the content of the file from the persistence system. <code>save</code> Save the content of the file into the persistence system. <code>delete</code> Delete the file from the persistence system."},{"location":"file_repositories/#repositories","title":"Repositories","text":"<p>To change the repository you only need to change the url passed to <code>load_file_repository</code>. We have the next repositories:</p> <ul> <li>LocalFileRepository: stores the file contents in     the local file system.</li> </ul>"},{"location":"local_file_repository/","title":"LocalFileRepository","text":"<p>The <code>LocalFileRepository</code> stores the file contents in the local file system.</p> <p>It stores the File's contents in a file in the local file system.</p> <p>Imagine you want to save the contents in <code>/srv/file_data</code>, you'll then initialize the repository with:</p> <pre><code>from repository_orm import load_file_repository\n\nrepo = load_file_repository(\"local:/srv/file_data\")\n</code></pre>"},{"location":"local_file_repository/#features","title":"Features","text":"<p>Follow the overview example to see how to use each method.</p> <code>load</code> Load the content of the File from a file in the local filesystem. <code>save</code> Save the content of the File to a file in the local filesystem. <code>delete</code> Delete the file from the local filesystem."},{"location":"models/","title":"Models","text":"<p>When modeling the application logic through Domain Driven Design, you usually need the following object types:</p> <ul> <li> <p>Value object: Any domain object that is uniquely identified by the data it     holds, so it has no conceptual identity. They should be treated as     immutable. We can still have complex behaviour in value objects.     In fact, it's common to support operations, for example, mathematical     operators.</p> </li> <li> <p>Entity: An object that is not defined by it's attributes, but rather by     a thread of continuity and it's identity. Unlike values, they have identity     equality. We can change their values, and they are still recognizably the     same thing.</p> </li> </ul>"},{"location":"models/#entities","title":"Entities","text":"<p>The Entity class is based on the pydantic's <code>BaseModel</code> to enforce that they have the <code>id_</code> attribute of type <code>int</code>, <code>str</code> or <code>AnyHttpUrl</code>, used for comparison and hashing of entities.</p> <p>They also have a private <code>model_name</code> property with the name of the model.</p> <p>If you use integer IDs (which is the default), you don't need to define the <code>id_</code> at object creation. When you add the entity to the repository, it will populate it.</p> <pre><code>from repository_orm import Entity, load_repository\n\n\nclass Author(Entity):\n    first_name: str\n\n\nrepo = load_repository()\n\n\nauthor = Author(first_name=\"Brandon\")\n\n# Add entities\nrepo.add(author)\nrepo.commit()\n\n# Retrieve entities by their ID\nbrandon = repo.get(0, Author)\nassert brandon == author # noqa\n</code></pre> <p>!!! warning \"This will only work with <code>int</code> ids! For the rest of the cases you need to give the <code>id_</code> yourself.\"</p>"},{"location":"models/#merging-entities","title":"Merging entities","text":"<p>Entities have a <code>merge</code> method that let's you update it's attributes with the ones of another entity.</p> <pre><code>from repository_orm import Entity\n\n\nclass Author(Entity):\n    name: str\n    is_alive: bool = True\n\n\nauthor = Author(name=\"Brandon\")\n\n# Imagine a complex process here that creates an updated version of the author object\nnew_author = Author(name=\"New name\", is_alive=False)\n\nauthor.merge(new_author)\nassert author.name == \"New name\"\nassert not author.is_alive\n\n# Nevertheless the default values are not merged!\nauthor.merge(Author(name=\"Brandon\"))\nassert not author.is_alive\n\n# Unless specified by the user\nauthor.merge(Author(name=\"Brandon\", is_alive=True))\nassert author.is_alive # noqa\n</code></pre> <p>For two entities to be mergeable, they need to belong from the same model and have the same <code>id_</code>. The previous example worked because by default the <code>id_</code> is <code>-1</code> until the entity is added to the repository. If you want to check other attribute to see if the objects are mergeable, probably that attribute should be the <code>id_</code> instead.</p> <p>If you don't want to propagate some attributes when merging, add them to the <code>_skip_on_merge</code> configuration option of the model:</p> <pre><code>from datetime import datetime\n\nfrom repository_orm import Entity\n\n\nclass Author(Entity):\n    name: str\n    is_alive: bool = True\n    birthday: datetime\n    _skip_on_merge = [\"birthday\"]\n\n\nauthor = Author(name=\"Brandon\", birthday=datetime(2020, 1, 1))\nnew_author = Author(name=\"Brandon\", birthday=datetime(1900, 1, 1), is_alive=False)\n\nauthor.merge(new_author)\nassert author.birthday == datetime(2020, 1, 1)\nassert not author.is_alive # noqa\n</code></pre>"},{"location":"models/#files","title":"Files","text":"<p>The File class is a special Entity model used to work with computer files.</p> <p>It has useful attributes like:</p> <ul> <li><code>path</code>.</li> <li><code>created_at</code>.</li> <li><code>updated_at</code>.</li> <li><code>owner</code>.</li> <li><code>group</code>.</li> <li><code>permissions</code>.</li> </ul> <p>And methods:</p> <ul> <li><code>basename</code>.</li> <li><code>dirname</code>.</li> <li><code>extension</code>.</li> </ul> <p>Until Pydantic <code>1.9</code> is released, you need to store the content in the file using the <code>_content</code> attribute, to access the content, you can use <code>content</code> directly.</p>"},{"location":"new_repo/","title":"Create new repository","text":"<p>First make sure you've read the contributing guidelines.</p> <p>All repository types are run against the same tests.</p> <p>Using the awesome library pytest-cases, we were able to separate the test cases from the test functions. The result is not simple to understand, but bear with me, as once you understand it, you may love it.</p> <p>The test cases are in the <code>cases</code> directory below <code>tests</code>. There are two files:</p> <ul> <li><code>entities.py</code>:     Where we define the different Entity objects to test through the methods of     the <code>EntityCases</code> class.</li> <li><code>repositories.py</code>:     Where we define the different Repository objects to test through the methods of     the <code>RepositoryCases</code> class.</li> </ul> <p>The Entity cases, return a factory defined with Factoryboy together with the Entity model, to create arbitrary objects with real values generated through Faker.</p> <p>The Repository cases are a little more complex, each of them returns a tuple with the following objects:</p> <ul> <li><code>db</code>: A storage connection object to run direct queries in the tests.</li> <li><code>empty_repo</code>: A repository instance without the schema applied.</li> <li><code>repo</code>: A repository instance with the schema applied.</li> <li><code>repo_tester</code>: A class to particularize the testing interface to each     repository.</li> </ul> <p>Each repository needs different assertions to ensure that a functionality works as expected, this fact makes it really difficult to parametrize the tests. The solution I've found is to write the tests Making generic tests for</p> <p>The Entities to test are defined in the The interface definition of all repositories is done at the Repository class.</p>"},{"location":"pypika_repository/","title":"PypikaRepository","text":"<p>The <code>PypikaRepository</code> is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases.</p> <p>It stores the persisted Entities into a SQLite database tables (Mysql support will come in the future).</p> <p>It uses the Pypika query builder to generate the raw SQL statements and then sends them to the database through an sqlite3 connection. If you're wondering why we don't want to use SQLAlchemy or raw sql statements, check this article.</p> <p>Load it with:</p> <pre><code>from repository_orm import load_repository\n\nrepo = load_repository('sqlite://path/to/database.db')\n</code></pre>"},{"location":"pypika_repository/#database-schema","title":"Database schema","text":"<p>The repository assumes there is a specific schema, where the table names are the same as the Entity clases in lowercase, and the columns are called as the attributes. All tables must have an <code>id</code> column. Following the overview example, the database should contain one table called <code>author</code> with the columns <code>id</code>, <code>first_name</code>, <code>last_name</code> and <code>country</code>.</p> <p>For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example.</p>"},{"location":"pypika_repository/#features","title":"Features","text":"<p>Follow the overview example to see how to use each method.</p> <code>add</code> Appends the <code>Entity</code> object to its table by translating its attributes to the columns. If it already exists, use the upsert statement to update it's attributes in the table. <code>delete</code> Deletes the <code>Entity</code> object from its table by searching the row that matches the object ID. <code>get</code> Obtain an <code>Entity</code> by extracting the row that matches the ID and build the <code>Entity</code> object with that data. <code>commit</code> Persist the changes into the database. <code>all</code> Obtain all the entities of type <code>Entity</code>. Similar to the <code>get</code> method but for all entities. <code>search</code> Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. <code>apply_migrations</code> Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the <code>migrations</code> directory."},{"location":"pypika_repository/#internal-workings","title":"Internal workings","text":"<p>This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood.</p> <p>Once the object is initialized with the database url with the format <code>sqlite:///path_to_database_file</code>, an <code>sqlite3</code> <code>Connection</code> object is saved in the <code>connection</code> attribute, and a first <code>Cursor</code> is saved to the <code>cursor</code> attribute.</p> <p>If you need to execute new queries, use the <code>_execute</code> method, it accepts a Pypika <code>Query</code> object. To extract the Pypika <code>Table</code> from an identity object, use the <code>_table</code> static method, or the <code>_table_model</code> if you use an identity class instead.</p> <p>Keep in mind that if you use the internal methods, like <code>_execute</code>, in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository.</p> <p>If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library.</p> <p>There is also the <code>_build_entities</code> method that accepts an <code>Entity</code> class and a <code>Query</code> and returns a list of the entities built from the data of the query.</p>"},{"location":"pypika_repository/#references","title":"References","text":"<ul> <li>Pypika documentation</li> <li>Yoyo documentation</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#repository_orm","title":"<code>repository_orm</code>","text":"<p>Library to ease the implementation of the repository pattern in Python projects.</p>"},{"location":"reference/#repository_orm.AutoIncrementError","title":"<code>AutoIncrementError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when the id_ auto increment repository feature fails.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class AutoIncrementError(Exception):\n\"\"\"Raised when the id_ auto increment repository feature fails.\"\"\"\n</code></pre>"},{"location":"reference/#repository_orm.Entity","title":"<code>Entity</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Model of any object no defined by it's attributes whom instead has an identity.</p> <p>Unlike value objects, they have identity equality. We can change their values, and they are still recognizably the same thing.</p> <p>An entity with a negative id means that the id needs to be set by the repository.</p> <p>The _defined_values are used to know which attributes were set by the user at the time of merging objects.</p> Source code in <code>repository_orm/model.py</code> <pre><code>class Entity(BaseModel):\n\"\"\"Model of any object no defined by it's attributes whom instead has an identity.\n\n    Unlike value objects, they have *identity equality*. We can change their values, and\n    they are still recognizably the same thing.\n\n    An entity with a negative id means that the id needs to be set by the repository.\n\n    The _defined_values are used to know which attributes were set by the user at the\n    time of merging objects.\n    \"\"\"\n\n    id_: EntityID = -1\n    _defined_values: Dict[str, Any] = PrivateAttr()\n    _skip_on_merge: List[str] = []\n\n    # ANN401: Any not allowed, but it's what we have.\n    def __init__(self, **data: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Initialize the defined values.\"\"\"\n        super().__init__(**data)\n        self._defined_values = data\n\n    def __lt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is smaller than us.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if isinstance(other.id_, int) and isinstance(self.id_, int):\n            return self.id_ &lt; other.id_\n        return str(self.id_) &lt; str(other.id_)\n\n    def __gt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is greater than us.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if isinstance(other.id_, int) and isinstance(self.id_, int):\n            return self.id_ &gt; other.id_\n        return str(self.id_) &gt; str(other.id_)\n\n    def __hash__(self) -&gt; int:\n\"\"\"Create an unique hash of the class object.\"\"\"\n        return hash(f\"{self.model_name}-{self.id_}\")\n\n    # ANN401: Any not allowed, but it's what we have.\n    def __setattr__(self, attribute: str, value: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Store the set attribute into the _defined_values.\"\"\"\n        if attribute != \"_defined_values\":\n            self._defined_values[attribute] = value\n        super().__setattr__(attribute, value)\n\n    @property\n    def model_name(self) -&gt; str:\n\"\"\"Return the entity model name.\"\"\"\n        return self.schema()[\"title\"]\n\n    def merge(self, other: \"Entity\") -&gt; \"Entity\":\n\"\"\"Update the attributes with the ones manually set by the user of other.\n\n        If the other object has default values not set by the user, they won't be\n        propagated to `self`.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if not isinstance(other, type(self)):\n            raise ValueError(\n                \"Can't merge objects of different models \"\n                f\"({self.model_name} with {other.model_name}).\"\n            )\n        if self.id_ != other.id_:\n            raise ValueError(f\"Can't merge two {self.model_name}s with different ids\")\n\n        # Merge objects\n        # W0212: access to an internal property, but it's managed by us so there is\n        # no problem on it.\n        for attribute, value in other._defined_values.items():  # noqa: W0212\n            if attribute not in self._skip_on_merge:\n                setattr(self, attribute, value)\n\n        return self\n\n    @property\n    def defined_values(self) -&gt; Dict[str, Any]:\n\"\"\"Return the entity defined values.\"\"\"\n        return self._defined_values\n\n    def clear_defined_values(self) -&gt; None:\n\"\"\"Remove all references to defined values.\n\n        I tried to return self so that it can be used chained with repo.get(), but I get\n        a mypy error `Incompatible return value type (got \"Entity\", expected \"Entity\")`\n        \"\"\"\n        self._defined_values = {}\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Assert if an object is greater than us.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def __gt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is greater than us.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if isinstance(other.id_, int) and isinstance(self.id_, int):\n        return self.id_ &gt; other.id_\n    return str(self.id_) &gt; str(other.id_)\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.__hash__","title":"<code>__hash__()</code>","text":"<p>Create an unique hash of the class object.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Create an unique hash of the class object.\"\"\"\n    return hash(f\"{self.model_name}-{self.id_}\")\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initialize the defined values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Initialize the defined values.\"\"\"\n    super().__init__(**data)\n    self._defined_values = data\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Assert if an object is smaller than us.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def __lt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is smaller than us.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if isinstance(other.id_, int) and isinstance(self.id_, int):\n        return self.id_ &lt; other.id_\n    return str(self.id_) &lt; str(other.id_)\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.__setattr__","title":"<code>__setattr__(attribute, value)</code>","text":"<p>Store the set attribute into the _defined_values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __setattr__(self, attribute: str, value: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Store the set attribute into the _defined_values.\"\"\"\n    if attribute != \"_defined_values\":\n        self._defined_values[attribute] = value\n    super().__setattr__(attribute, value)\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.clear_defined_values","title":"<code>clear_defined_values()</code>","text":"<p>Remove all references to defined values.</p> <p>I tried to return self so that it can be used chained with repo.get(), but I get a mypy error <code>Incompatible return value type (got \"Entity\", expected \"Entity\")</code></p> Source code in <code>repository_orm/model.py</code> <pre><code>def clear_defined_values(self) -&gt; None:\n\"\"\"Remove all references to defined values.\n\n    I tried to return self so that it can be used chained with repo.get(), but I get\n    a mypy error `Incompatible return value type (got \"Entity\", expected \"Entity\")`\n    \"\"\"\n    self._defined_values = {}\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.defined_values","title":"<code>defined_values()</code>  <code>property</code>","text":"<p>Return the entity defined values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef defined_values(self) -&gt; Dict[str, Any]:\n\"\"\"Return the entity defined values.\"\"\"\n    return self._defined_values\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.merge","title":"<code>merge(other)</code>","text":"<p>Update the attributes with the ones manually set by the user of other.</p> <p>If the other object has default values not set by the user, they won't be propagated to <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def merge(self, other: \"Entity\") -&gt; \"Entity\":\n\"\"\"Update the attributes with the ones manually set by the user of other.\n\n    If the other object has default values not set by the user, they won't be\n    propagated to `self`.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if not isinstance(other, type(self)):\n        raise ValueError(\n            \"Can't merge objects of different models \"\n            f\"({self.model_name} with {other.model_name}).\"\n        )\n    if self.id_ != other.id_:\n        raise ValueError(f\"Can't merge two {self.model_name}s with different ids\")\n\n    # Merge objects\n    # W0212: access to an internal property, but it's managed by us so there is\n    # no problem on it.\n    for attribute, value in other._defined_values.items():  # noqa: W0212\n        if attribute not in self._skip_on_merge:\n            setattr(self, attribute, value)\n\n    return self\n</code></pre>"},{"location":"reference/#repository_orm.model.Entity.model_name","title":"<code>model_name()</code>  <code>property</code>","text":"<p>Return the entity model name.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef model_name(self) -&gt; str:\n\"\"\"Return the entity model name.\"\"\"\n    return self.schema()[\"title\"]\n</code></pre>"},{"location":"reference/#repository_orm.EntityNotFoundError","title":"<code>EntityNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when the search or retrieve of an entity fails.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class EntityNotFoundError(Exception):\n\"\"\"Raised when the search or retrieve of an entity fails.\"\"\"\n</code></pre>"},{"location":"reference/#repository_orm.FakeRepository","title":"<code>FakeRepository</code>","text":"<p>         Bases: <code>Repository</code></p> <p>Implement the repository pattern using a memory dictionary.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>class FakeRepository(Repository):\n\"\"\"Implement the repository pattern using a memory dictionary.\"\"\"\n\n    def __init__(\n        self,\n        database_url: str = \"\",\n    ) -&gt; None:\n\"\"\"Initialize the repository attributes.\"\"\"\n        super().__init__()\n        if database_url == \"/inexistent_dir/database.db\":\n            raise ConnectionError(f\"Could not create database file: {database_url}\")\n        # ignore: Type variable \"repository_orm.adapters.data.fake.Entity\" is unbound\n        # I don't know how to fix this\n        self.entities: FakeRepositoryDB[EntityT] = {}  # type: ignore\n        self.new_entities: FakeRepositoryDB[EntityT] = {}  # type: ignore\n        self.is_connection_closed = False\n\n    def _add(self, entity: EntityT) -&gt; EntityT:\n\"\"\"Append an entity to the repository.\n\n        Args:\n            entity: Entity to add to the repository.\n\n        Returns:\n            entity\n        \"\"\"\n        if self.new_entities == {}:\n            self.new_entities = copy.deepcopy(self.entities.copy())\n        try:\n            self.new_entities[type(entity)]\n        except KeyError:\n            self.new_entities[type(entity)] = {}\n\n        self.new_entities[type(entity)][entity.id_] = entity\n\n        return entity\n\n    def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n        Args:\n            entity: Entity to remove from the repository.\n\n        Raises:\n            EntityNotFoundError: If the entity is not found.\n        \"\"\"\n        if self.new_entities == {}:\n            self.new_entities = copy.deepcopy(self.entities.copy())\n        try:\n            self.new_entities[type(entity)].pop(entity.id_, None)\n        except KeyError as error:\n            raise EntityNotFoundError(\n                f\"Unable to delete entity {entity} because it's not in the repository\"\n            ) from error\n\n    def _get(\n        self,\n        value: EntityID,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; List[EntityT]:\n\"\"\"Obtain all entities from the repository that match an id_.\n\n        If the attribute argument is passed, check that attribute instead.\n\n        Args:\n            value: Value of the entity attribute to obtain.\n            model: Entity class to obtain.\n            attribute: Entity attribute to check.\n\n        Returns:\n            entities: All entities that match the criteria.\n        \"\"\"\n        matching_entities = []\n\n        if attribute == \"id_\":\n            with suppress(KeyError):\n                matching_entities.append(self.entities[model][value])\n        else:\n            matching_entities = self._search({attribute: value}, model)\n\n        return copy.deepcopy(matching_entities)\n\n    def _all(self, model: Type[EntityT]) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n        \"\"\"\n        entities = []\n\n        with suppress(KeyError):\n            entities += sorted(\n                entity for entity_id, entity in self.entities[model].items()\n            )\n\n        return entities\n\n    def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n        for model, entities in self.new_entities.items():\n            self.entities[model] = entities\n        self.new_entities = {}\n\n    def _search(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            entities: List of Entity object that matches the search criteria.\n        \"\"\"\n        all_entities = self.all(model)\n        entities_dict = {entity.id_: entity for entity in all_entities}\n        entity_attributes = {entity.id_: entity.dict() for entity in all_entities}\n\n        for key, value in fields.items():\n            # Get entities that have the value `value`\n            entities_with_value = entity_attributes | grep(\n                value, use_regexp=True, strict_checking=False\n            )\n            matching_entity_attributes = {}\n\n            try:\n                entities_with_value[\"matched_values\"]\n            except KeyError:\n                return []\n\n            for path in entities_with_value[\"matched_values\"]:\n                entity_id = re.sub(r\"root\\['?(.*?)'?\\]\\[.*\", r\"\\1\", path)\n\n                # Convert int ids from str to int\n                try:\n                    # ignore: waiting for ADR-006 to be resolved\n                    entity_id = int(entity_id)  # type: ignore\n                except ValueError:\n                    entity_id = re.sub(r\"'(.*)'\", r\"\\1\", entity_id)\n\n                # Add the entity to the matching ones only if the value is of the\n                # attribute `key`.\n                if re.match(rf\"root\\['?{entity_id}'?\\]\\['{key}'\\]\", path):\n                    matching_entity_attributes[entity_id] = extract(\n                        entity_attributes, f\"root[{entity_id}]\"\n                    )\n            # ignore: waiting for ADR-006 to be resolved\n            entity_attributes = matching_entity_attributes  # type: ignore\n        entities = [entities_dict[key] for key in entity_attributes.keys()]\n\n        return entities\n\n    def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n        Args:\n            migrations_directory: path to the directory containing the migration\n                scripts.\n        \"\"\"\n        # The fake repository doesn't have any schema\n\n    def last(\n        self,\n        model: Type[EntityT],\n    ) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n        Args:\n            model: Entity class to obtain.\n\n        Returns:\n            entity: Biggest Entity object that matches a model.\n\n        Raises:\n            EntityNotFoundError: If there are no entities.\n        \"\"\"\n        try:\n            last_index_entity = super().last(model)\n        except EntityNotFoundError as empty_repo:\n            try:\n                # Empty repo but entities staged to be commited.\n                return max(self._staged_entities(model))\n            except KeyError as no_staged_entities:\n                # Empty repo and no entities staged.\n                raise empty_repo from no_staged_entities\n\n        try:\n            last_staged_entity = max(self._staged_entities(model))\n        except KeyError:\n            # Full repo and no staged entities.\n            return last_index_entity\n\n        # Full repo and staged entities.\n        return max([last_index_entity, last_staged_entity])\n\n    def _staged_entities(self, model: Type[EntityT]) -&gt; List[EntityT]:\n\"\"\"Return a list of staged entities of a model type.\n\n        Args:\n            model: Return only instances of this model.\n        \"\"\"\n        return [entity for _, entity in self.new_entities[model].items()]\n\n    def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n        self.is_connection_closed = True\n\n    @property\n    def is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n        return self.is_connection_closed\n\n    def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n        self.entities = {}\n        self.new_entities = {}\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.__init__","title":"<code>__init__(database_url='')</code>","text":"<p>Initialize the repository attributes.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def __init__(\n    self,\n    database_url: str = \"\",\n) -&gt; None:\n\"\"\"Initialize the repository attributes.\"\"\"\n    super().__init__()\n    if database_url == \"/inexistent_dir/database.db\":\n        raise ConnectionError(f\"Could not create database file: {database_url}\")\n    # ignore: Type variable \"repository_orm.adapters.data.fake.Entity\" is unbound\n    # I don't know how to fix this\n    self.entities: FakeRepositoryDB[EntityT] = {}  # type: ignore\n    self.new_entities: FakeRepositoryDB[EntityT] = {}  # type: ignore\n    self.is_connection_closed = False\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.apply_migrations","title":"<code>apply_migrations(migrations_directory)</code>","text":"<p>Run the migrations of the repository schema.</p> <p>Parameters:</p> Name Type Description Default <code>migrations_directory</code> <code>str</code> <p>path to the directory containing the migration scripts.</p> required Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n    Args:\n        migrations_directory: path to the directory containing the migration\n            scripts.\n    \"\"\"\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.close","title":"<code>close()</code>","text":"<p>Close the connection to the database.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n    self.is_connection_closed = True\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.commit","title":"<code>commit()</code>","text":"<p>Persist the changes into the repository.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n    for model, entities in self.new_entities.items():\n        self.entities[model] = entities\n    self.new_entities = {}\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.delete","title":"<code>delete(entity)</code>","text":"<p>Delete an entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityT</code> <p>Entity to remove from the repository.</p> required <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If the entity is not found.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n    Args:\n        entity: Entity to remove from the repository.\n\n    Raises:\n        EntityNotFoundError: If the entity is not found.\n    \"\"\"\n    if self.new_entities == {}:\n        self.new_entities = copy.deepcopy(self.entities.copy())\n    try:\n        self.new_entities[type(entity)].pop(entity.id_, None)\n    except KeyError as error:\n        raise EntityNotFoundError(\n            f\"Unable to delete entity {entity} because it's not in the repository\"\n        ) from error\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.empty","title":"<code>empty()</code>","text":"<p>Remove all entities from the repository.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n    self.entities = {}\n    self.new_entities = {}\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.is_closed","title":"<code>is_closed()</code>  <code>property</code>","text":"<p>Inform if the connection is closed.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>@property\ndef is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n    return self.is_connection_closed\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.fake.FakeRepository.last","title":"<code>last(model)</code>","text":"<p>Get the biggest entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class to obtain.</p> required <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityT</code> <p>Biggest Entity object that matches a model.</p> <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If there are no entities.</p> Source code in <code>repository_orm/adapters/data/fake.py</code> <pre><code>def last(\n    self,\n    model: Type[EntityT],\n) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n    Args:\n        model: Entity class to obtain.\n\n    Returns:\n        entity: Biggest Entity object that matches a model.\n\n    Raises:\n        EntityNotFoundError: If there are no entities.\n    \"\"\"\n    try:\n        last_index_entity = super().last(model)\n    except EntityNotFoundError as empty_repo:\n        try:\n            # Empty repo but entities staged to be commited.\n            return max(self._staged_entities(model))\n        except KeyError as no_staged_entities:\n            # Empty repo and no entities staged.\n            raise empty_repo from no_staged_entities\n\n    try:\n        last_staged_entity = max(self._staged_entities(model))\n    except KeyError:\n        # Full repo and no staged entities.\n        return last_index_entity\n\n    # Full repo and staged entities.\n    return max([last_index_entity, last_staged_entity])\n</code></pre>"},{"location":"reference/#repository_orm.File","title":"<code>File</code>","text":"<p>         Bases: <code>Entity</code>, <code>Generic[AnyStr]</code></p> <p>Model a computer file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>class File(Entity, Generic[AnyStr]):\n\"\"\"Model a computer file.\"\"\"\n\n    path: str\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    owner: Optional[str] = None\n    group: Optional[str] = None\n    permissions: Optional[str] = None\n\n    # The use of a private attribute and the impossibility of loading the content\n    # at object creation will be fixed on Pydantic 1.9.\n    # We will be able to define the excluded attribute content in the Config of the\n    # model.\n    #\n    # For more information on how to improve this code, read this:\n    # https://lyz-code.github.io/blue-book/coding/python/pydantic/#define-fields-to-exclude-from-exporting-at-config-level # noqa:E501\n    _content: Optional[AnyStr] = PrivateAttr(None)\n    # If the content is of type bytes\n    is_bytes: bool = False\n\n    @property\n    def basename(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return os.path.basename(self.path)\n\n    @property\n    def dirname(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return os.path.dirname(self.path)\n\n    @property\n    def extension(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return self.basename.split(\".\")[-1]\n\n    @property\n    def content(self) -&gt; AnyStr:\n\"\"\"Return the content of the file.\n\n        Returns:\n            The content of the file.\n\n        Raises:\n            FileContentNotLoadedError: if the content is not yet loaded.\n        \"\"\"\n        if self._content is None:\n            raise FileContentNotLoadedError(\n                \"The content of the file has not been loaded yet.\"\n            )\n        return self._content\n</code></pre>"},{"location":"reference/#repository_orm.model.File.basename","title":"<code>basename()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef basename(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return os.path.basename(self.path)\n</code></pre>"},{"location":"reference/#repository_orm.model.File.content","title":"<code>content()</code>  <code>property</code>","text":"<p>Return the content of the file.</p> <p>Returns:</p> Type Description <code>AnyStr</code> <p>The content of the file.</p> <p>Raises:</p> Type Description <code>FileContentNotLoadedError</code> <p>if the content is not yet loaded.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef content(self) -&gt; AnyStr:\n\"\"\"Return the content of the file.\n\n    Returns:\n        The content of the file.\n\n    Raises:\n        FileContentNotLoadedError: if the content is not yet loaded.\n    \"\"\"\n    if self._content is None:\n        raise FileContentNotLoadedError(\n            \"The content of the file has not been loaded yet.\"\n        )\n    return self._content\n</code></pre>"},{"location":"reference/#repository_orm.model.File.dirname","title":"<code>dirname()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef dirname(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return os.path.dirname(self.path)\n</code></pre>"},{"location":"reference/#repository_orm.model.File.extension","title":"<code>extension()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef extension(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return self.basename.split(\".\")[-1]\n</code></pre>"},{"location":"reference/#repository_orm.LocalFileRepository","title":"<code>LocalFileRepository</code>","text":"<p>         Bases: <code>FileRepository[AnyStr]</code></p> <p>Define the local filesystem adapter.</p> Source code in <code>repository_orm/adapters/file/local_file.py</code> <pre><code>class LocalFileRepository(FileRepository[AnyStr]):\n\"\"\"Define the local filesystem adapter.\"\"\"\n\n    def __init__(self, workdir: str) -&gt; None:\n\"\"\"Initialize the object.\n\n        Creates the working directory if it doesn't exist.\n        \"\"\"\n        if not os.path.exists(workdir):\n            os.makedirs(workdir)\n        super().__init__(workdir=workdir)\n\n    def load(self, file_: File[AnyStr]) -&gt; File[AnyStr]:\n\"\"\"Load the content of the file from the persistence system.\"\"\"\n        log.debug(f\"Loading content of file {file_.path}\")\n        file_ = self.fix_path(file_)\n        if file_.is_bytes:\n            mode = \"rb\"\n            encoding = None\n        else:\n            mode = \"r\"\n            encoding = \"utf-8\"\n\n        with open(\n            os.path.expanduser(file_.path), mode, encoding=encoding\n        ) as file_descriptor:\n            # W0212: Access to private attribute, but it's managed by us so it's OK\n            file_._content = file_descriptor.read()  # noqa: W0212\n        return file_\n\n    def save(self, file_: File[AnyStr]) -&gt; File[AnyStr]:\n\"\"\"Save the content of the file into the persistence system.\"\"\"\n        log.debug(f\"Saving the content of file {file_.path}\")\n        file_ = self.fix_path(file_)\n        if file_.is_bytes:\n            mode = \"wb+\"\n        else:\n            mode = \"w+\"\n\n        with open(os.path.expanduser(file_.path), mode) as file_descriptor:\n            file_descriptor.write(file_.content)\n\n        return file_\n\n    def delete(self, file_: File[AnyStr]) -&gt; None:\n\"\"\"Delete the file from the persistence system.\"\"\"\n        log.debug(f\"Deleting the content of file {file_.path}\")\n        try:\n            os.remove(os.path.expanduser(file_.path))\n        except FileNotFoundError:\n            log.warning(\n                f\"Can't remove the file {file_.path} as it doesn't exist \"\n                \"in the file repository.\"\n            )\n</code></pre>"},{"location":"reference/#repository_orm.adapters.file.local_file.LocalFileRepository.__init__","title":"<code>__init__(workdir)</code>","text":"<p>Initialize the object.</p> <p>Creates the working directory if it doesn't exist.</p> Source code in <code>repository_orm/adapters/file/local_file.py</code> <pre><code>def __init__(self, workdir: str) -&gt; None:\n\"\"\"Initialize the object.\n\n    Creates the working directory if it doesn't exist.\n    \"\"\"\n    if not os.path.exists(workdir):\n        os.makedirs(workdir)\n    super().__init__(workdir=workdir)\n</code></pre>"},{"location":"reference/#repository_orm.adapters.file.local_file.LocalFileRepository.delete","title":"<code>delete(file_)</code>","text":"<p>Delete the file from the persistence system.</p> Source code in <code>repository_orm/adapters/file/local_file.py</code> <pre><code>def delete(self, file_: File[AnyStr]) -&gt; None:\n\"\"\"Delete the file from the persistence system.\"\"\"\n    log.debug(f\"Deleting the content of file {file_.path}\")\n    try:\n        os.remove(os.path.expanduser(file_.path))\n    except FileNotFoundError:\n        log.warning(\n            f\"Can't remove the file {file_.path} as it doesn't exist \"\n            \"in the file repository.\"\n        )\n</code></pre>"},{"location":"reference/#repository_orm.adapters.file.local_file.LocalFileRepository.load","title":"<code>load(file_)</code>","text":"<p>Load the content of the file from the persistence system.</p> Source code in <code>repository_orm/adapters/file/local_file.py</code> <pre><code>def load(self, file_: File[AnyStr]) -&gt; File[AnyStr]:\n\"\"\"Load the content of the file from the persistence system.\"\"\"\n    log.debug(f\"Loading content of file {file_.path}\")\n    file_ = self.fix_path(file_)\n    if file_.is_bytes:\n        mode = \"rb\"\n        encoding = None\n    else:\n        mode = \"r\"\n        encoding = \"utf-8\"\n\n    with open(\n        os.path.expanduser(file_.path), mode, encoding=encoding\n    ) as file_descriptor:\n        # W0212: Access to private attribute, but it's managed by us so it's OK\n        file_._content = file_descriptor.read()  # noqa: W0212\n    return file_\n</code></pre>"},{"location":"reference/#repository_orm.adapters.file.local_file.LocalFileRepository.save","title":"<code>save(file_)</code>","text":"<p>Save the content of the file into the persistence system.</p> Source code in <code>repository_orm/adapters/file/local_file.py</code> <pre><code>def save(self, file_: File[AnyStr]) -&gt; File[AnyStr]:\n\"\"\"Save the content of the file into the persistence system.\"\"\"\n    log.debug(f\"Saving the content of file {file_.path}\")\n    file_ = self.fix_path(file_)\n    if file_.is_bytes:\n        mode = \"wb+\"\n    else:\n        mode = \"w+\"\n\n    with open(os.path.expanduser(file_.path), mode) as file_descriptor:\n        file_descriptor.write(file_.content)\n\n    return file_\n</code></pre>"},{"location":"reference/#repository_orm.PypikaRepository","title":"<code>PypikaRepository</code>","text":"<p>         Bases: <code>Repository</code></p> <p>Implement the repository pattern using the Pypika query builder.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>class PypikaRepository(Repository):\n\"\"\"Implement the repository pattern using the Pypika query builder.\"\"\"\n\n    def __init__(\n        self,\n        database_url: str = \"\",\n    ) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n        Args:\n            database_url: URL specifying the connection to the database.\n        \"\"\"\n        super().__init__(database_url)\n        database_file = database_url.replace(\"sqlite:///\", \"\")\n        if not os.path.isfile(database_file):\n            try:\n                with open(database_file, \"a\", encoding=\"utf-8\") as file_cursor:\n                    file_cursor.close()\n            except FileNotFoundError as error:\n                raise ConnectionError(\n                    f\"Could not create the database file: {database_file}\"\n                ) from error\n        self.connection = sqlite3.connect(database_file)\n        self.connection.create_function(\"REGEXP\", 2, _regexp)\n        self.cursor = self.connection.cursor()\n\n    def _execute(self, query: Union[Query, str]) -&gt; sqlite3.Cursor:\n\"\"\"Execute an SQL statement from a Pypika query object.\n\n        Args:\n            query: Pypika query\n        \"\"\"\n        return self.cursor.execute(str(query))\n\n    @staticmethod\n    def _table(entity: EntityT) -&gt; Table:\n\"\"\"Return the table of the selected entity object.\"\"\"\n        return Table(entity.model_name.lower())\n\n    @staticmethod\n    def _table_model(model: Type[EntityT]) -&gt; Table:\n\"\"\"Return the table of the selected entity class.\"\"\"\n        return Table(model.__name__.lower())\n\n    def _add(self, entity: EntityT) -&gt; EntityT:\n\"\"\"Append an entity to the repository.\n\n        If the id is not set, autoincrement the last.\n\n        Args:\n            entity: Entity to add to the repository.\n\n        Returns:\n            entity\n        \"\"\"\n        table = self._table(entity)\n        columns = list(entity.dict().keys())\n        columns[columns.index(\"id_\")] = \"id\"\n        values = [value for key, value in entity.dict().items()]\n        insert_query = Query.into(table).columns(tuple(columns)).insert(tuple(values))\n        # Until https://github.com/kayak/pypika/issues/535 is solved we need to write\n        # The upsert statement ourselves.\n        # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through\n        #   string-based query construction. We're not letting the user define the\n        #   values of the query, the only variable inputs are the keys, that are\n        #   defined by the developer, so it's not probable that he chooses an\n        #   entity attributes that are an SQL injection. Once the #535 issue is\n        #   solved, we should get rid of this error too.\n        upsert_query = (\n            str(insert_query)\n            + \" ON CONFLICT(id) DO UPDATE SET \"  # nosec\n            + \", \".join([f\"{key}=excluded.{key}\" for key in columns])\n        )\n        self._execute(upsert_query)\n\n        return entity\n\n    def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n        Args:\n            entity: Entity to remove from the repository.\n\n        Raises:\n            EntityNotFoundError: If the entity is not found.\n        \"\"\"\n        table = self._table(entity)\n        try:\n            self.get(entity.id_, type(entity))\n        except EntityNotFoundError as error:\n            raise EntityNotFoundError(\n                f\"Unable to delete entity {entity} because it's not in the repository\"\n            ) from error\n        query = Query.from_(table).delete().where(table.id == entity.id_)\n        self._execute(query)\n\n    def _get(\n        self,\n        value: EntityID,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; List[EntityT]:\n\"\"\"Obtain all entities from the repository that match an id_.\n\n        If the attribute argument is passed, check that attribute instead.\n\n        Args:\n            value: Value of the entity attribute to obtain.\n            model: Entity class to obtain.\n            attribute: Entity attribute to check.\n\n        Returns:\n            entities: All entities that match the criteria.\n        \"\"\"\n        table = self._table_model(model)\n        query = Query.from_(table).select(\"*\")\n        if attribute == \"id_\":\n            query = query.where(table.id == value)\n        else:\n            query = query.where(getattr(table, attribute) == value)\n\n        return self._build_entities(model, query)\n\n    def _all(self, model: Type[EntityT]) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n        \"\"\"\n        table = self._table_model(model)\n        query = Query.from_(table).select(\"*\")\n        return self._build_entities(model, query)\n\n    def _build_entities(self, model: Type[EntityT], query: Query) -&gt; List[EntityT]:\n\"\"\"Build Entity objects from the data extracted from the database.\n\n        Args:\n            model: Entity class model to build.\n            query: pypika query of the entities you want to build\n        \"\"\"\n        cursor = self._execute(query)\n\n        entities_data = cursor.fetchall()\n        attributes = [description[0] for description in cursor.description]\n\n        entities = []\n        for entity_data in entities_data:\n            entity_dict = {\n                attributes[index]: entity_data[index]\n                for index in range(0, len(entity_data))\n            }\n            entity_dict[\"id_\"] = entity_dict.pop(\"id\")\n\n            entities.append(model(**entity_dict))\n        return entities\n\n    def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n        self.connection.commit()\n\n    def _search(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            entities: List of Entity object that matches the search criteria.\n        \"\"\"\n        table = self._table_model(model)\n        query = Query.from_(table).select(\"*\")\n\n        for key, value in fields.items():\n            if key == \"id_\":\n                key = \"id\"\n            if isinstance(value, str):\n                query = query.where(\n                    functions.Lower(getattr(table, key)).regexp(value.lower())\n                )\n            else:\n                query = query.where(getattr(table, key) == value)\n\n        return self._build_entities(model, query)\n\n    def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n        Args:\n            migrations_directory: path to the directory containing the migration\n                scripts.\n        \"\"\"\n        backend = get_backend(self.database_url)\n        migrations = read_migrations(migrations_directory)\n\n        with backend.lock():\n            log.info(\"Running database migrations\")\n            try:\n                backend.apply_migrations(backend.to_apply(migrations))\n            except Exception as error:  # noqa: W0703\n                # We need to add tests for this function and use a less generic\n                # exception\n                log.error(\"Error running database migrations\")\n                log.error(error)\n\n                log.debug(\"Rolling back the database migrations\")\n                try:\n                    backend.rollback_migrations(backend.to_rollback(migrations))\n                except Exception as rollback_error:  # noqa: W0703\n                    # We need to add tests for this function and use a less generic\n                    # exception\n                    log.error(\"Error rolling back database migrations\")\n                    log.error(rollback_error)\n                    raise rollback_error from error\n            log.debug(\"Complete running database migrations\")\n\n    def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n        self.connection.close()\n\n    def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n        for table in self.tables:\n            self._execute(Query.from_(table).delete())\n\n    @property\n    def tables(self) -&gt; List[str]:\n\"\"\"Return the entity tables of the database.\"\"\"\n        if re.match(\"sqlite://\", self.database_url):\n            query = \"SELECT name FROM sqlite_master WHERE type='table'\"\n\n        tables = [\n            table[0]\n            for table in self._execute(query).fetchall()\n            if not re.match(r\"^_\", table[0]) and not re.match(\"yoyo\", table[0])\n        ]\n        return tables\n\n    @property\n    def is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n        try:\n            self.connection.cursor()\n            return False\n        except ProgrammingError:\n            return True\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.__init__","title":"<code>__init__(database_url='')</code>","text":"<p>Initialize the repository attributes.</p> <p>Parameters:</p> Name Type Description Default <code>database_url</code> <code>str</code> <p>URL specifying the connection to the database.</p> <code>''</code> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def __init__(\n    self,\n    database_url: str = \"\",\n) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n    Args:\n        database_url: URL specifying the connection to the database.\n    \"\"\"\n    super().__init__(database_url)\n    database_file = database_url.replace(\"sqlite:///\", \"\")\n    if not os.path.isfile(database_file):\n        try:\n            with open(database_file, \"a\", encoding=\"utf-8\") as file_cursor:\n                file_cursor.close()\n        except FileNotFoundError as error:\n            raise ConnectionError(\n                f\"Could not create the database file: {database_file}\"\n            ) from error\n    self.connection = sqlite3.connect(database_file)\n    self.connection.create_function(\"REGEXP\", 2, _regexp)\n    self.cursor = self.connection.cursor()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.apply_migrations","title":"<code>apply_migrations(migrations_directory)</code>","text":"<p>Run the migrations of the repository schema.</p> <p>Parameters:</p> Name Type Description Default <code>migrations_directory</code> <code>str</code> <p>path to the directory containing the migration scripts.</p> required Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n    Args:\n        migrations_directory: path to the directory containing the migration\n            scripts.\n    \"\"\"\n    backend = get_backend(self.database_url)\n    migrations = read_migrations(migrations_directory)\n\n    with backend.lock():\n        log.info(\"Running database migrations\")\n        try:\n            backend.apply_migrations(backend.to_apply(migrations))\n        except Exception as error:  # noqa: W0703\n            # We need to add tests for this function and use a less generic\n            # exception\n            log.error(\"Error running database migrations\")\n            log.error(error)\n\n            log.debug(\"Rolling back the database migrations\")\n            try:\n                backend.rollback_migrations(backend.to_rollback(migrations))\n            except Exception as rollback_error:  # noqa: W0703\n                # We need to add tests for this function and use a less generic\n                # exception\n                log.error(\"Error rolling back database migrations\")\n                log.error(rollback_error)\n                raise rollback_error from error\n        log.debug(\"Complete running database migrations\")\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.close","title":"<code>close()</code>","text":"<p>Close the connection to the database.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n    self.connection.close()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.commit","title":"<code>commit()</code>","text":"<p>Persist the changes into the repository.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n    self.connection.commit()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.delete","title":"<code>delete(entity)</code>","text":"<p>Delete an entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityT</code> <p>Entity to remove from the repository.</p> required <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If the entity is not found.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n    Args:\n        entity: Entity to remove from the repository.\n\n    Raises:\n        EntityNotFoundError: If the entity is not found.\n    \"\"\"\n    table = self._table(entity)\n    try:\n        self.get(entity.id_, type(entity))\n    except EntityNotFoundError as error:\n        raise EntityNotFoundError(\n            f\"Unable to delete entity {entity} because it's not in the repository\"\n        ) from error\n    query = Query.from_(table).delete().where(table.id == entity.id_)\n    self._execute(query)\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.empty","title":"<code>empty()</code>","text":"<p>Remove all entities from the repository.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n    for table in self.tables:\n        self._execute(Query.from_(table).delete())\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.is_closed","title":"<code>is_closed()</code>  <code>property</code>","text":"<p>Inform if the connection is closed.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>@property\ndef is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n    try:\n        self.connection.cursor()\n        return False\n    except ProgrammingError:\n        return True\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.pypika.PypikaRepository.tables","title":"<code>tables()</code>  <code>property</code>","text":"<p>Return the entity tables of the database.</p> Source code in <code>repository_orm/adapters/data/pypika.py</code> <pre><code>@property\ndef tables(self) -&gt; List[str]:\n\"\"\"Return the entity tables of the database.\"\"\"\n    if re.match(\"sqlite://\", self.database_url):\n        query = \"SELECT name FROM sqlite_master WHERE type='table'\"\n\n    tables = [\n        table[0]\n        for table in self._execute(query).fetchall()\n        if not re.match(r\"^_\", table[0]) and not re.match(\"yoyo\", table[0])\n    ]\n    return tables\n</code></pre>"},{"location":"reference/#repository_orm.Repository","title":"<code>Repository</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Gather common methods and define the interface of the repositories.</p> <p>Attributes:</p> Name Type Description <code>database_url</code> <p>URL specifying the connection to the database.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>class Repository(abc.ABC):\n\"\"\"Gather common methods and define the interface of the repositories.\n\n    Attributes:\n        database_url: URL specifying the connection to the database.\n    \"\"\"\n\n    @abc.abstractmethod\n    def __init__(\n        self,\n        database_url: str = \"\",\n    ) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n        Args:\n            database_url: URL specifying the connection to the database.\n        \"\"\"\n        self.database_url = database_url\n        self.cache = Cache()\n\n    def add(\n        self, entities: EntityOrEntitiesT, merge: bool = False\n    ) -&gt; EntityOrEntitiesT:\n\"\"\"Append an entity or list of entities to the repository.\n\n        If the id is not set, it will automatically increment the last available one.\n\n        If `merge` is True, added entities will be merged with the existent ones in\n        the cache.\n\n        Args:\n            entities: Entity or entities to add to the repository.\n\n        Returns:\n            entity or entities\n        \"\"\"\n        if isinstance(entities, Entity):\n            entity = entities\n\n            if isinstance(entity.id_, int) and entity.id_ &lt; 0:\n                entity.id_ = self.next_id(entity)\n\n            if merge:\n                with suppress(EntityNotFoundError):\n                    stored_entity = self.get(entity.id_, type(entity))\n                    entity = stored_entity.merge(entity)\n\n            if self.cache.entity_has_not_changed(entity):\n                log.debug(\n                    f\"Skipping the addition of entity {entity} as it hasn't changed\"\n                )\n                return entity\n            entity = self._add(entity)\n            self.cache.add(entity)\n            return entity\n\n        if isinstance(entities, list):\n            updated_entities: List[Entity] = []\n            for entity in entities:\n                updated_entities.append(self.add(entity, merge))\n            return updated_entities\n\n        raise ValueError(\"Please add an entity or a list of entities\")\n\n    @abc.abstractmethod\n    def _add(self, entity: EntityT) -&gt; EntityT:\n\"\"\"Append an entity to the repository.\n\n        This method is specific to each database adapter.\n\n        Args:\n            entity: Entity to add to the repository.\n\n        Returns:\n            entity\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n        Args:\n            entity: Entity to remove from the repository.\n        \"\"\"\n        raise NotImplementedError\n\n    def get(\n        self,\n        id_: EntityID,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; EntityT:\n\"\"\"Obtain an entity from the repository by it's ID.\n\n        Also save the entity in the cache\n\n        Args:\n            model: Entity class to obtain.\n            id_: ID of the entity to obtain.\n\n        Returns:\n            entity: Entity object that matches the id_\n\n        Raises:\n            EntityNotFoundError: If the entity is not found.\n            TooManyEntitiesError: If more than one entity was found.\n        \"\"\"\n        entities = self._get(value=id_, model=model, attribute=attribute)\n\n        if len(entities) &gt; 1:\n            raise TooManyEntitiesError(\n                f\"More than one entity was found with the {attribute} {id_}\"\n            )\n        if len(entities) == 0:\n            raise EntityNotFoundError(\n                f\"There are no entities of type {model.__name__} in the repository \"\n                f\"with {attribute} {id_}.\"\n            )\n\n        entity = entities[0]\n        entity.clear_defined_values()\n        self.cache.add(entity)\n        return entity\n\n    @abc.abstractmethod\n    def _get(\n        self,\n        value: EntityID,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; List[EntityT]:\n\"\"\"Obtain all entities from the repository that match an id_.\n\n        If the attribute argument is passed, check that attribute instead.\n\n        Args:\n            value: Value of the entity attribute to obtain.\n            model: Entity class to obtain.\n            attribute: Entity attribute to check.\n\n        Returns:\n            entities: All entities that match the criteria.\n        \"\"\"\n        raise NotImplementedError\n\n    def all(\n        self,\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n        Also store the entities in the cache.\n\n        Args:\n            model: Entity class or classes to obtain.\n        \"\"\"\n        entities = sorted(self._all(model))\n\n        for entity in entities:\n            entity.clear_defined_values()\n            self.cache.add(entity)\n\n        return entities\n\n    @abc.abstractmethod\n    def _all(self, model: Type[EntityT]) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n        raise NotImplementedError\n\n    def search(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n        Also add the found entities to the cache.\n\n        Args:\n            model: Entity class to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            entities: List of Entity object that matches the search criteria.\n        \"\"\"\n        found_entities = sorted(self._search(fields, model))\n\n        for entity in found_entities:\n            entity.clear_defined_values()\n            self.cache.add(entity)\n\n        return found_entities\n\n    @abc.abstractmethod\n    def _search(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            entities: List of Entity object that matches the search criteria.\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n        Args:\n            migrations_directory: path to the directory containing the migration\n                scripts.\n        \"\"\"\n        raise NotImplementedError\n\n    def last(\n        self,\n        model: Type[EntityT],\n    ) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n        Args:\n            model: Entity class to obtain.\n\n        Returns:\n            entity: Biggest Entity object that matches a model.\n\n        Raises:\n            EntityNotFoundError: If there are no entities.\n        \"\"\"\n        try:\n            return max(self.all(model))\n        except ValueError as error:\n            raise EntityNotFoundError(\n                f\"There are no entities of type {model.__name__} in the repository.\"\n            ) from error\n\n    def first(\n        self,\n        model: Type[EntityT],\n    ) -&gt; EntityT:\n\"\"\"Get the smallest entity from the repository.\n\n        Args:\n            model: Type of entity object to obtain.\n\n        Returns:\n            entity: Smallest Entity object that matches a model.\n\n        Raises:\n            EntityNotFoundError: If there are no entities.\n        \"\"\"\n        try:\n            return min(self.all(model))\n        except ValueError as error:\n            raise EntityNotFoundError(\n                f\"There are no entities of type {model.__name__} in the repository.\"\n            ) from error\n\n    def next_id(self, entity: EntityT) -&gt; int:\n\"\"\"Return one id unit more than the last entity id in the repository index.\n\n        Args:\n            entity: Entity whose model we want to get the next entity id.\n        \"\"\"\n        try:\n            last_id = self.last(type(entity)).id_\n        except EntityNotFoundError:\n            return 0\n        if isinstance(last_id, int):\n            return last_id + 1\n        raise AutoIncrementError(\n            \"Auto increment is not yet supported for Entities with string id_s. \"\n            \"Please set the id_ yourself before adding the entities to the \"\n            \"repository.\"\n        )\n\n    @abc.abstractmethod\n    def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.__init__","title":"<code>__init__(database_url='')</code>  <code>abstractmethod</code>","text":"<p>Initialize the repository attributes.</p> <p>Parameters:</p> Name Type Description Default <code>database_url</code> <code>str</code> <p>URL specifying the connection to the database.</p> <code>''</code> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef __init__(\n    self,\n    database_url: str = \"\",\n) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n    Args:\n        database_url: URL specifying the connection to the database.\n    \"\"\"\n    self.database_url = database_url\n    self.cache = Cache()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.add","title":"<code>add(entities, merge=False)</code>","text":"<p>Append an entity or list of entities to the repository.</p> <p>If the id is not set, it will automatically increment the last available one.</p> <p>If <code>merge</code> is True, added entities will be merged with the existent ones in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityOrEntitiesT</code> <p>Entity or entities to add to the repository.</p> required <p>Returns:</p> Type Description <code>EntityOrEntitiesT</code> <p>entity or entities</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def add(\n    self, entities: EntityOrEntitiesT, merge: bool = False\n) -&gt; EntityOrEntitiesT:\n\"\"\"Append an entity or list of entities to the repository.\n\n    If the id is not set, it will automatically increment the last available one.\n\n    If `merge` is True, added entities will be merged with the existent ones in\n    the cache.\n\n    Args:\n        entities: Entity or entities to add to the repository.\n\n    Returns:\n        entity or entities\n    \"\"\"\n    if isinstance(entities, Entity):\n        entity = entities\n\n        if isinstance(entity.id_, int) and entity.id_ &lt; 0:\n            entity.id_ = self.next_id(entity)\n\n        if merge:\n            with suppress(EntityNotFoundError):\n                stored_entity = self.get(entity.id_, type(entity))\n                entity = stored_entity.merge(entity)\n\n        if self.cache.entity_has_not_changed(entity):\n            log.debug(\n                f\"Skipping the addition of entity {entity} as it hasn't changed\"\n            )\n            return entity\n        entity = self._add(entity)\n        self.cache.add(entity)\n        return entity\n\n    if isinstance(entities, list):\n        updated_entities: List[Entity] = []\n        for entity in entities:\n            updated_entities.append(self.add(entity, merge))\n        return updated_entities\n\n    raise ValueError(\"Please add an entity or a list of entities\")\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.all","title":"<code>all(model)</code>","text":"<p>Get all the entities from the repository that match a model.</p> <p>Also store the entities in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class or classes to obtain.</p> required Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def all(\n    self,\n    model: Type[EntityT],\n) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n    Also store the entities in the cache.\n\n    Args:\n        model: Entity class or classes to obtain.\n    \"\"\"\n    entities = sorted(self._all(model))\n\n    for entity in entities:\n        entity.clear_defined_values()\n        self.cache.add(entity)\n\n    return entities\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.apply_migrations","title":"<code>apply_migrations(migrations_directory)</code>  <code>abstractmethod</code>","text":"<p>Run the migrations of the repository schema.</p> <p>Parameters:</p> Name Type Description Default <code>migrations_directory</code> <code>str</code> <p>path to the directory containing the migration scripts.</p> required Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n    Args:\n        migrations_directory: path to the directory containing the migration\n            scripts.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.close","title":"<code>close()</code>  <code>abstractmethod</code>","text":"<p>Close the connection to the database.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.commit","title":"<code>commit()</code>  <code>abstractmethod</code>","text":"<p>Persist the changes into the repository.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.delete","title":"<code>delete(entity)</code>  <code>abstractmethod</code>","text":"<p>Delete an entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityT</code> <p>Entity to remove from the repository.</p> required Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n    Args:\n        entity: Entity to remove from the repository.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.empty","title":"<code>empty()</code>  <code>abstractmethod</code>","text":"<p>Remove all entities from the repository.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@abc.abstractmethod\ndef empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.first","title":"<code>first(model)</code>","text":"<p>Get the smallest entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Type of entity object to obtain.</p> required <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityT</code> <p>Smallest Entity object that matches a model.</p> <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If there are no entities.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def first(\n    self,\n    model: Type[EntityT],\n) -&gt; EntityT:\n\"\"\"Get the smallest entity from the repository.\n\n    Args:\n        model: Type of entity object to obtain.\n\n    Returns:\n        entity: Smallest Entity object that matches a model.\n\n    Raises:\n        EntityNotFoundError: If there are no entities.\n    \"\"\"\n    try:\n        return min(self.all(model))\n    except ValueError as error:\n        raise EntityNotFoundError(\n            f\"There are no entities of type {model.__name__} in the repository.\"\n        ) from error\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.get","title":"<code>get(id_, model, attribute='id_')</code>","text":"<p>Obtain an entity from the repository by it's ID.</p> <p>Also save the entity in the cache</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class to obtain.</p> required <code>id_</code> <code>EntityID</code> <p>ID of the entity to obtain.</p> required <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityT</code> <p>Entity object that matches the id_</p> <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If the entity is not found.</p> <code>TooManyEntitiesError</code> <p>If more than one entity was found.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def get(\n    self,\n    id_: EntityID,\n    model: Type[EntityT],\n    attribute: str = \"id_\",\n) -&gt; EntityT:\n\"\"\"Obtain an entity from the repository by it's ID.\n\n    Also save the entity in the cache\n\n    Args:\n        model: Entity class to obtain.\n        id_: ID of the entity to obtain.\n\n    Returns:\n        entity: Entity object that matches the id_\n\n    Raises:\n        EntityNotFoundError: If the entity is not found.\n        TooManyEntitiesError: If more than one entity was found.\n    \"\"\"\n    entities = self._get(value=id_, model=model, attribute=attribute)\n\n    if len(entities) &gt; 1:\n        raise TooManyEntitiesError(\n            f\"More than one entity was found with the {attribute} {id_}\"\n        )\n    if len(entities) == 0:\n        raise EntityNotFoundError(\n            f\"There are no entities of type {model.__name__} in the repository \"\n            f\"with {attribute} {id_}.\"\n        )\n\n    entity = entities[0]\n    entity.clear_defined_values()\n    self.cache.add(entity)\n    return entity\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.is_closed","title":"<code>is_closed()</code>  <code>property</code> <code>abstractmethod</code>","text":"<p>Inform if the connection is closed.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>@property\n@abc.abstractmethod\ndef is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.last","title":"<code>last(model)</code>","text":"<p>Get the biggest entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class to obtain.</p> required <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityT</code> <p>Biggest Entity object that matches a model.</p> <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If there are no entities.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def last(\n    self,\n    model: Type[EntityT],\n) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n    Args:\n        model: Entity class to obtain.\n\n    Returns:\n        entity: Biggest Entity object that matches a model.\n\n    Raises:\n        EntityNotFoundError: If there are no entities.\n    \"\"\"\n    try:\n        return max(self.all(model))\n    except ValueError as error:\n        raise EntityNotFoundError(\n            f\"There are no entities of type {model.__name__} in the repository.\"\n        ) from error\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.next_id","title":"<code>next_id(entity)</code>","text":"<p>Return one id unit more than the last entity id in the repository index.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityT</code> <p>Entity whose model we want to get the next entity id.</p> required Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def next_id(self, entity: EntityT) -&gt; int:\n\"\"\"Return one id unit more than the last entity id in the repository index.\n\n    Args:\n        entity: Entity whose model we want to get the next entity id.\n    \"\"\"\n    try:\n        last_id = self.last(type(entity)).id_\n    except EntityNotFoundError:\n        return 0\n    if isinstance(last_id, int):\n        return last_id + 1\n    raise AutoIncrementError(\n        \"Auto increment is not yet supported for Entities with string id_s. \"\n        \"Please set the id_ yourself before adding the entities to the \"\n        \"repository.\"\n    )\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.abstract.Repository.search","title":"<code>search(fields, model)</code>","text":"<p>Get the entities whose attributes match one or several conditions.</p> <p>Also add the found entities to the cache.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class to obtain.</p> required <code>fields</code> <code>Dict[str, EntityID]</code> <p>Dictionary with the {key}:{value} to search.</p> required <p>Returns:</p> Name Type Description <code>entities</code> <code>List[EntityT]</code> <p>List of Entity object that matches the search criteria.</p> Source code in <code>repository_orm/adapters/data/abstract.py</code> <pre><code>def search(\n    self,\n    fields: Dict[str, EntityID],\n    model: Type[EntityT],\n) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n    Also add the found entities to the cache.\n\n    Args:\n        model: Entity class to obtain.\n        fields: Dictionary with the {key}:{value} to search.\n\n    Returns:\n        entities: List of Entity object that matches the search criteria.\n    \"\"\"\n    found_entities = sorted(self._search(fields, model))\n\n    for entity in found_entities:\n        entity.clear_defined_values()\n        self.cache.add(entity)\n\n    return found_entities\n</code></pre>"},{"location":"reference/#repository_orm.TinyDBRepository","title":"<code>TinyDBRepository</code>","text":"<p>         Bases: <code>Repository</code></p> <p>Implement the repository pattern using the TinyDB.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>class TinyDBRepository(Repository):\n\"\"\"Implement the repository pattern using the TinyDB.\"\"\"\n\n    def __init__(\n        self,\n        database_url: str = \"\",\n    ) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n        Args:\n            database_url: URL specifying the connection to the database.\n        \"\"\"\n        super().__init__(database_url)\n        self.database_file = os.path.expanduser(database_url.replace(\"tinydb://\", \"\"))\n        if not os.path.isfile(self.database_file):\n            try:\n                with open(self.database_file, \"a\", encoding=\"utf-8\") as file_cursor:\n                    file_cursor.close()\n            except FileNotFoundError as error:\n                raise ConnectionError(\n                    f\"Could not create the database file: {self.database_file}\"\n                ) from error\n\n        serialization = SerializationMiddleware(JSONStorage)\n        serialization.register_serializer(DateTimeSerializer(), \"TinyDate\")\n\n        self.db_ = TinyDB(\n            self.database_file, storage=serialization, sort_keys=True, indent=4\n        )\n        self.staged: Dict[str, List[Any]] = {\"add\": [], \"remove\": []}\n\n    def _add(self, entity: EntityT) -&gt; EntityT:\n\"\"\"Append an entity to the repository.\n\n        If the id is not set, autoincrement the last.\n\n        Args:\n            entity: Entity to add to the repository.\n\n        Returns:\n            entity\n        \"\"\"\n        self.staged[\"add\"].append(entity)\n\n        return entity\n\n    def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n        Args:\n            entity: Entity to remove from the repository.\n        \"\"\"\n        try:\n            self.get(entity.id_, type(entity))\n        except EntityNotFoundError as error:\n            raise EntityNotFoundError(\n                f\"Unable to delete entity {entity} because it's not in the repository\"\n            ) from error\n        self.staged[\"remove\"].append(entity)\n\n    def _get(\n        self,\n        value: EntityID,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; List[EntityT]:\n\"\"\"Obtain all entities from the repository that match an id_.\n\n        If the attribute argument is passed, check that attribute instead.\n\n        Args:\n            value: Value of the entity attribute to obtain.\n            model: Entity class to obtain.\n            attribute: Entity attribute to check.\n\n        Returns:\n            entities: All entities that match the criteria.\n        \"\"\"\n        model_query = Query().model_type_ == model.__name__.lower()\n\n        matching_entities_data = self.db_.search(\n            (Query()[attribute] == value) &amp; (model_query)\n        )\n\n        return [\n            self._build_entity(entity_data, model)\n            for entity_data in matching_entities_data\n        ]\n\n    @staticmethod\n    def _build_entity(\n        entity_data: Dict[Any, Any],\n        model: Type[EntityT],\n    ) -&gt; EntityT:\n\"\"\"Create an entity from the data stored in a row of the database.\n\n        Args:\n            entity_data: Dictionary with the attributes of the entity.\n            model: Type of entity object to obtain.\n\n        Returns:\n            entity: Built Entity.\n        \"\"\"\n        # If we don't copy the data, the all method stop being idempotent.\n        entity_data = entity_data.copy()\n        try:\n            return model.parse_obj(entity_data)\n        except ValidationError as error:\n            log.error(\n                f\"Error loading the model {model.__name__} \"\n                f\"for the register {str(entity_data)}\"\n            )\n            raise error\n\n    def _all(self, model: Type[EntityT]) -&gt; List[EntityT]:\n\"\"\"Get all the entities from the repository that match a model.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n        \"\"\"\n        entities = []\n\n        query = Query().model_type_ == model.__name__.lower()\n        entities_data = self.db_.search(query)\n\n        for entity_data in entities_data:\n            entities.append(self._build_entity(entity_data, model))\n\n        return entities\n\n    @staticmethod\n    def _export_entity(entity: EntityT) -&gt; Dict[Any, Any]:\n\"\"\"Export the attributes of the entity appending the required by TinyDB.\n\n        Args:\n            entity: Entity to export.\n\n        Returns:\n            entity_data: Dictionary with the attributes of the entity.\n        \"\"\"\n        entity_data = entity.dict()\n        entity_data[\"model_type_\"] = entity.model_name.lower()\n\n        return entity_data\n\n    def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n        for entity in self.staged[\"add\"]:\n            self.db_.upsert(\n                self._export_entity(entity),\n                (Query().model_type_ == entity.model_name.lower())\n                &amp; (Query().id_ == entity.id_),\n            )\n        self.staged[\"add\"].clear()\n\n        for entity in self.staged[\"remove\"]:\n            self.db_.remove(\n                (Query().model_type_ == entity.model_name.lower())\n                &amp; (Query().id_ == entity.id_)\n            )\n        self.staged[\"remove\"].clear()\n\n    def _search(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]:\n\"\"\"Get the entities whose attributes match one or several conditions.\n\n        Particular implementation of the database adapter.\n\n        Args:\n            model: Entity class to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            entities: List of Entity object that matches the search criteria.\n        \"\"\"\n        entities = []\n        try:\n            query = self._build_search_query(fields, model)\n        except EntityNotFoundError:\n            return []\n\n        # Build entities\n        entities_data = self.db_.search(query)\n\n        for entity_data in entities_data:\n            entities.append(self._build_entity(entity_data, model))\n\n        return entities\n\n    def _build_search_query(\n        self,\n        fields: Dict[str, EntityID],\n        model: Type[EntityT],\n    ) -&gt; QueryInstance:\n\"\"\"Build the Query parts for a repository search.\n\n        If the field type is a list, change the query accordingly.\n\n        Args:\n            model: Type of entity object to obtain.\n            fields: Dictionary with the {key}:{value} to search.\n\n        Returns:\n            Query based on the type of model and fields.\n        \"\"\"\n        query_parts = []\n\n        schema = model.schema()[\"properties\"]\n        for field, value in fields.items():\n            if field not in schema.keys():\n                continue\n\n            with suppress(KeyError):\n                if schema[field][\"type\"] == \"array\":\n                    query_parts.append(\n                        (Query().model_type_ == model.__name__.lower())\n                        &amp; (Query()[field].test(_regexp_in_list, value))\n                    )\n                    continue\n\n            if isinstance(value, str):\n                query_parts.append(\n                    (Query().model_type_ == model.__name__.lower())\n                    &amp; (Query()[field].search(value, flags=re.IGNORECASE))\n                )\n            else:\n                query_parts.append(\n                    (Query().model_type_ == model.__name__.lower())\n                    &amp; (Query()[field] == value)\n                )\n        if len(query_parts) != 0:\n            return self._merge_query(query_parts, mode=\"and\")\n\n        raise EntityNotFoundError(\n            f\"There are no entities of type {model.__name__} in the repository \"\n            f\" that match the search filter {fields}\"\n        )\n\n    @staticmethod\n    def _merge_query(\n        query_parts: List[QueryInstance], mode: str = \"and\"\n    ) -&gt; QueryInstance:\n\"\"\"Join all the query parts into a query.\n\n        Args:\n            query_parts: List of queries to concatenate.\n            mode: \"and\" or \"or\" for the join method.\n\n        Returns:\n            A query object that joins all parts.\n        \"\"\"\n        query = query_parts[0]\n\n        for query_part in query_parts[1:]:\n            if mode == \"and\":\n                query = query &amp; query_part\n            else:\n                query = query | query_part\n\n        return query\n\n    def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n        Args:\n            migrations_directory: path to the directory containing the migration\n                scripts.\n        \"\"\"\n        raise NotImplementedError\n\n    def last(\n        self,\n        model: Type[EntityT],\n    ) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n        Args:\n            model: Entity class to obtain.\n\n        Returns:\n            entity: Biggest Entity object that matches a model.\n\n        Raises:\n            EntityNotFoundError: If there are no entities.\n        \"\"\"\n        try:\n            last_index_entity = super().last(model)\n        except EntityNotFoundError as empty_repo:\n            try:\n                # Empty repo but entities staged to be commited.\n                return max(\n                    entity for entity in self.staged[\"add\"] if entity.__class__ == model\n                )\n            except ValueError as no_staged_entities:\n                # Empty repo and no entities staged.\n                raise empty_repo from no_staged_entities\n\n        try:\n            last_staged_entity = max(\n                entity for entity in self.staged[\"add\"] if entity.__class__ == model\n            )\n        except ValueError:\n            # Full repo and no staged entities.\n            return last_index_entity\n\n        # Full repo and staged entities.\n        return max([last_index_entity, last_staged_entity])\n\n    def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n        self.db_.close()\n\n    @property\n    def is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n        try:\n            self.db_.tables()\n            return False\n        except ValueError:\n            return True\n\n    def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n        self.db_.truncate()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.__init__","title":"<code>__init__(database_url='')</code>","text":"<p>Initialize the repository attributes.</p> <p>Parameters:</p> Name Type Description Default <code>database_url</code> <code>str</code> <p>URL specifying the connection to the database.</p> <code>''</code> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def __init__(\n    self,\n    database_url: str = \"\",\n) -&gt; None:\n\"\"\"Initialize the repository attributes.\n\n    Args:\n        database_url: URL specifying the connection to the database.\n    \"\"\"\n    super().__init__(database_url)\n    self.database_file = os.path.expanduser(database_url.replace(\"tinydb://\", \"\"))\n    if not os.path.isfile(self.database_file):\n        try:\n            with open(self.database_file, \"a\", encoding=\"utf-8\") as file_cursor:\n                file_cursor.close()\n        except FileNotFoundError as error:\n            raise ConnectionError(\n                f\"Could not create the database file: {self.database_file}\"\n            ) from error\n\n    serialization = SerializationMiddleware(JSONStorage)\n    serialization.register_serializer(DateTimeSerializer(), \"TinyDate\")\n\n    self.db_ = TinyDB(\n        self.database_file, storage=serialization, sort_keys=True, indent=4\n    )\n    self.staged: Dict[str, List[Any]] = {\"add\": [], \"remove\": []}\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.apply_migrations","title":"<code>apply_migrations(migrations_directory)</code>","text":"<p>Run the migrations of the repository schema.</p> <p>Parameters:</p> Name Type Description Default <code>migrations_directory</code> <code>str</code> <p>path to the directory containing the migration scripts.</p> required Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def apply_migrations(self, migrations_directory: str) -&gt; None:\n\"\"\"Run the migrations of the repository schema.\n\n    Args:\n        migrations_directory: path to the directory containing the migration\n            scripts.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.close","title":"<code>close()</code>","text":"<p>Close the connection to the database.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"Close the connection to the database.\"\"\"\n    self.db_.close()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.commit","title":"<code>commit()</code>","text":"<p>Persist the changes into the repository.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def commit(self) -&gt; None:\n\"\"\"Persist the changes into the repository.\"\"\"\n    for entity in self.staged[\"add\"]:\n        self.db_.upsert(\n            self._export_entity(entity),\n            (Query().model_type_ == entity.model_name.lower())\n            &amp; (Query().id_ == entity.id_),\n        )\n    self.staged[\"add\"].clear()\n\n    for entity in self.staged[\"remove\"]:\n        self.db_.remove(\n            (Query().model_type_ == entity.model_name.lower())\n            &amp; (Query().id_ == entity.id_)\n        )\n    self.staged[\"remove\"].clear()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.delete","title":"<code>delete(entity)</code>","text":"<p>Delete an entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityT</code> <p>Entity to remove from the repository.</p> required Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def delete(self, entity: EntityT) -&gt; None:\n\"\"\"Delete an entity from the repository.\n\n    Args:\n        entity: Entity to remove from the repository.\n    \"\"\"\n    try:\n        self.get(entity.id_, type(entity))\n    except EntityNotFoundError as error:\n        raise EntityNotFoundError(\n            f\"Unable to delete entity {entity} because it's not in the repository\"\n        ) from error\n    self.staged[\"remove\"].append(entity)\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.empty","title":"<code>empty()</code>","text":"<p>Remove all entities from the repository.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def empty(self) -&gt; None:\n\"\"\"Remove all entities from the repository.\"\"\"\n    self.db_.truncate()\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.is_closed","title":"<code>is_closed()</code>  <code>property</code>","text":"<p>Inform if the connection is closed.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>@property\ndef is_closed(self) -&gt; bool:\n\"\"\"Inform if the connection is closed.\"\"\"\n    try:\n        self.db_.tables()\n        return False\n    except ValueError:\n        return True\n</code></pre>"},{"location":"reference/#repository_orm.adapters.data.tinydb.TinyDBRepository.last","title":"<code>last(model)</code>","text":"<p>Get the biggest entity from the repository.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[EntityT]</code> <p>Entity class to obtain.</p> required <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityT</code> <p>Biggest Entity object that matches a model.</p> <p>Raises:</p> Type Description <code>EntityNotFoundError</code> <p>If there are no entities.</p> Source code in <code>repository_orm/adapters/data/tinydb.py</code> <pre><code>def last(\n    self,\n    model: Type[EntityT],\n) -&gt; EntityT:\n\"\"\"Get the biggest entity from the repository.\n\n    Args:\n        model: Entity class to obtain.\n\n    Returns:\n        entity: Biggest Entity object that matches a model.\n\n    Raises:\n        EntityNotFoundError: If there are no entities.\n    \"\"\"\n    try:\n        last_index_entity = super().last(model)\n    except EntityNotFoundError as empty_repo:\n        try:\n            # Empty repo but entities staged to be commited.\n            return max(\n                entity for entity in self.staged[\"add\"] if entity.__class__ == model\n            )\n        except ValueError as no_staged_entities:\n            # Empty repo and no entities staged.\n            raise empty_repo from no_staged_entities\n\n    try:\n        last_staged_entity = max(\n            entity for entity in self.staged[\"add\"] if entity.__class__ == model\n        )\n    except ValueError:\n        # Full repo and no staged entities.\n        return last_index_entity\n\n    # Full repo and staged entities.\n    return max([last_index_entity, last_staged_entity])\n</code></pre>"},{"location":"reference/#repository_orm.load_file_repository","title":"<code>load_file_repository(url='local:.')</code>","text":"<p>Load the FileRepository object that matches the url protocol.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Url to connect to the storage backend.</p> <code>'local:.'</code> <p>Returns:</p> Type Description <code>FileRepository[AnyStr]</code> <p>File Repository that understands the url protocol.</p> Source code in <code>repository_orm/services.py</code> <pre><code>def load_file_repository(url: str = \"local:.\") -&gt; \"FileRepository[AnyStr]\":\n\"\"\"Load the FileRepository object that matches the url protocol.\n\n    Args:\n        url: Url to connect to the storage backend.\n\n    Returns:\n        File Repository that understands the url protocol.\n    \"\"\"\n    if \"local:\" in url:\n        return LocalFileRepository(workdir=url.split(\":\")[1])\n\n    raise ValueError(f\"File Repository URL: {url} not recognized.\")\n</code></pre>"},{"location":"reference/#repository_orm.load_repository","title":"<code>load_repository(database_url='fake://')</code>","text":"<p>Load the Repository object that matches the database url protocol.</p> <p>Parameters:</p> Name Type Description Default <code>database_url</code> <code>str</code> <p>Url to connect to the storage backend.</p> <code>'fake://'</code> <p>Returns:</p> Type Description <code>Repository</code> <p>Repository that understands the url protocol.</p> Source code in <code>repository_orm/services.py</code> <pre><code>def load_repository(\n    database_url: str = \"fake://\",\n) -&gt; Repository:\n\"\"\"Load the Repository object that matches the database url protocol.\n\n    Args:\n        database_url: Url to connect to the storage backend.\n\n    Returns:\n        Repository that understands the url protocol.\n    \"\"\"\n    if \"fake://\" in database_url:\n        return FakeRepository(\"\")\n    if \"sqlite://\" in database_url:\n        return PypikaRepository(database_url)\n    if \"tinydb://\" in database_url:\n        return TinyDBRepository(database_url)\n\n    raise ValueError(f\"Database URL: {database_url} not recognized.\")\n</code></pre>"},{"location":"reference_adapters/","title":"Repository Implementations","text":""},{"location":"reference_adapters/#repository_orm.adapters","title":"<code>repository_orm.adapters</code>","text":""},{"location":"reference_exceptions/","title":"Exceptions","text":""},{"location":"reference_exceptions/#repository_orm.exceptions","title":"<code>repository_orm.exceptions</code>","text":"<p>Store the repository-orm exceptions.</p>"},{"location":"reference_exceptions/#repository_orm.exceptions.AutoIncrementError","title":"<code>AutoIncrementError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when the id_ auto increment repository feature fails.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class AutoIncrementError(Exception):\n\"\"\"Raised when the id_ auto increment repository feature fails.\"\"\"\n</code></pre>"},{"location":"reference_exceptions/#repository_orm.exceptions.EntityNotFoundError","title":"<code>EntityNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when the search or retrieve of an entity fails.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class EntityNotFoundError(Exception):\n\"\"\"Raised when the search or retrieve of an entity fails.\"\"\"\n</code></pre>"},{"location":"reference_exceptions/#repository_orm.exceptions.FileContentNotLoadedError","title":"<code>FileContentNotLoadedError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when trying to access the content of a file that has not been loaded.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class FileContentNotLoadedError(Exception):\n\"\"\"Raised when trying to access the content of a file that has not been loaded.\"\"\"\n</code></pre>"},{"location":"reference_exceptions/#repository_orm.exceptions.TooManyEntitiesError","title":"<code>TooManyEntitiesError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when more entities than expected where found.</p> Source code in <code>repository_orm/exceptions.py</code> <pre><code>class TooManyEntitiesError(Exception):\n\"\"\"Raised when more entities than expected where found.\"\"\"\n</code></pre>"},{"location":"reference_models/","title":"Models","text":""},{"location":"reference_models/#repository_orm.model","title":"<code>repository_orm.model</code>","text":"<p>Store the common business model of all entities.</p>"},{"location":"reference_models/#repository_orm.model.Entity","title":"<code>Entity</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Model of any object no defined by it's attributes whom instead has an identity.</p> <p>Unlike value objects, they have identity equality. We can change their values, and they are still recognizably the same thing.</p> <p>An entity with a negative id means that the id needs to be set by the repository.</p> <p>The _defined_values are used to know which attributes were set by the user at the time of merging objects.</p> Source code in <code>repository_orm/model.py</code> <pre><code>class Entity(BaseModel):\n\"\"\"Model of any object no defined by it's attributes whom instead has an identity.\n\n    Unlike value objects, they have *identity equality*. We can change their values, and\n    they are still recognizably the same thing.\n\n    An entity with a negative id means that the id needs to be set by the repository.\n\n    The _defined_values are used to know which attributes were set by the user at the\n    time of merging objects.\n    \"\"\"\n\n    id_: EntityID = -1\n    _defined_values: Dict[str, Any] = PrivateAttr()\n    _skip_on_merge: List[str] = []\n\n    # ANN401: Any not allowed, but it's what we have.\n    def __init__(self, **data: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Initialize the defined values.\"\"\"\n        super().__init__(**data)\n        self._defined_values = data\n\n    def __lt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is smaller than us.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if isinstance(other.id_, int) and isinstance(self.id_, int):\n            return self.id_ &lt; other.id_\n        return str(self.id_) &lt; str(other.id_)\n\n    def __gt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is greater than us.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if isinstance(other.id_, int) and isinstance(self.id_, int):\n            return self.id_ &gt; other.id_\n        return str(self.id_) &gt; str(other.id_)\n\n    def __hash__(self) -&gt; int:\n\"\"\"Create an unique hash of the class object.\"\"\"\n        return hash(f\"{self.model_name}-{self.id_}\")\n\n    # ANN401: Any not allowed, but it's what we have.\n    def __setattr__(self, attribute: str, value: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Store the set attribute into the _defined_values.\"\"\"\n        if attribute != \"_defined_values\":\n            self._defined_values[attribute] = value\n        super().__setattr__(attribute, value)\n\n    @property\n    def model_name(self) -&gt; str:\n\"\"\"Return the entity model name.\"\"\"\n        return self.schema()[\"title\"]\n\n    def merge(self, other: \"Entity\") -&gt; \"Entity\":\n\"\"\"Update the attributes with the ones manually set by the user of other.\n\n        If the other object has default values not set by the user, they won't be\n        propagated to `self`.\n\n        Args:\n            other: Entity to compare.\n        \"\"\"\n        if not isinstance(other, type(self)):\n            raise ValueError(\n                \"Can't merge objects of different models \"\n                f\"({self.model_name} with {other.model_name}).\"\n            )\n        if self.id_ != other.id_:\n            raise ValueError(f\"Can't merge two {self.model_name}s with different ids\")\n\n        # Merge objects\n        # W0212: access to an internal property, but it's managed by us so there is\n        # no problem on it.\n        for attribute, value in other._defined_values.items():  # noqa: W0212\n            if attribute not in self._skip_on_merge:\n                setattr(self, attribute, value)\n\n        return self\n\n    @property\n    def defined_values(self) -&gt; Dict[str, Any]:\n\"\"\"Return the entity defined values.\"\"\"\n        return self._defined_values\n\n    def clear_defined_values(self) -&gt; None:\n\"\"\"Remove all references to defined values.\n\n        I tried to return self so that it can be used chained with repo.get(), but I get\n        a mypy error `Incompatible return value type (got \"Entity\", expected \"Entity\")`\n        \"\"\"\n        self._defined_values = {}\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Assert if an object is greater than us.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def __gt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is greater than us.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if isinstance(other.id_, int) and isinstance(self.id_, int):\n        return self.id_ &gt; other.id_\n    return str(self.id_) &gt; str(other.id_)\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.__hash__","title":"<code>__hash__()</code>","text":"<p>Create an unique hash of the class object.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Create an unique hash of the class object.\"\"\"\n    return hash(f\"{self.model_name}-{self.id_}\")\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initialize the defined values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Initialize the defined values.\"\"\"\n    super().__init__(**data)\n    self._defined_values = data\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Assert if an object is smaller than us.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def __lt__(self, other: \"Entity\") -&gt; bool:\n\"\"\"Assert if an object is smaller than us.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if isinstance(other.id_, int) and isinstance(self.id_, int):\n        return self.id_ &lt; other.id_\n    return str(self.id_) &lt; str(other.id_)\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.__setattr__","title":"<code>__setattr__(attribute, value)</code>","text":"<p>Store the set attribute into the _defined_values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>def __setattr__(self, attribute: str, value: Any) -&gt; None:  # noqa: ANN401\n\"\"\"Store the set attribute into the _defined_values.\"\"\"\n    if attribute != \"_defined_values\":\n        self._defined_values[attribute] = value\n    super().__setattr__(attribute, value)\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.clear_defined_values","title":"<code>clear_defined_values()</code>","text":"<p>Remove all references to defined values.</p> <p>I tried to return self so that it can be used chained with repo.get(), but I get a mypy error <code>Incompatible return value type (got \"Entity\", expected \"Entity\")</code></p> Source code in <code>repository_orm/model.py</code> <pre><code>def clear_defined_values(self) -&gt; None:\n\"\"\"Remove all references to defined values.\n\n    I tried to return self so that it can be used chained with repo.get(), but I get\n    a mypy error `Incompatible return value type (got \"Entity\", expected \"Entity\")`\n    \"\"\"\n    self._defined_values = {}\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.defined_values","title":"<code>defined_values()</code>  <code>property</code>","text":"<p>Return the entity defined values.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef defined_values(self) -&gt; Dict[str, Any]:\n\"\"\"Return the entity defined values.\"\"\"\n    return self._defined_values\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.merge","title":"<code>merge(other)</code>","text":"<p>Update the attributes with the ones manually set by the user of other.</p> <p>If the other object has default values not set by the user, they won't be propagated to <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Entity</code> <p>Entity to compare.</p> required Source code in <code>repository_orm/model.py</code> <pre><code>def merge(self, other: \"Entity\") -&gt; \"Entity\":\n\"\"\"Update the attributes with the ones manually set by the user of other.\n\n    If the other object has default values not set by the user, they won't be\n    propagated to `self`.\n\n    Args:\n        other: Entity to compare.\n    \"\"\"\n    if not isinstance(other, type(self)):\n        raise ValueError(\n            \"Can't merge objects of different models \"\n            f\"({self.model_name} with {other.model_name}).\"\n        )\n    if self.id_ != other.id_:\n        raise ValueError(f\"Can't merge two {self.model_name}s with different ids\")\n\n    # Merge objects\n    # W0212: access to an internal property, but it's managed by us so there is\n    # no problem on it.\n    for attribute, value in other._defined_values.items():  # noqa: W0212\n        if attribute not in self._skip_on_merge:\n            setattr(self, attribute, value)\n\n    return self\n</code></pre>"},{"location":"reference_models/#repository_orm.model.Entity.model_name","title":"<code>model_name()</code>  <code>property</code>","text":"<p>Return the entity model name.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef model_name(self) -&gt; str:\n\"\"\"Return the entity model name.\"\"\"\n    return self.schema()[\"title\"]\n</code></pre>"},{"location":"reference_models/#repository_orm.model.File","title":"<code>File</code>","text":"<p>         Bases: <code>Entity</code>, <code>Generic[AnyStr]</code></p> <p>Model a computer file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>class File(Entity, Generic[AnyStr]):\n\"\"\"Model a computer file.\"\"\"\n\n    path: str\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    owner: Optional[str] = None\n    group: Optional[str] = None\n    permissions: Optional[str] = None\n\n    # The use of a private attribute and the impossibility of loading the content\n    # at object creation will be fixed on Pydantic 1.9.\n    # We will be able to define the excluded attribute content in the Config of the\n    # model.\n    #\n    # For more information on how to improve this code, read this:\n    # https://lyz-code.github.io/blue-book/coding/python/pydantic/#define-fields-to-exclude-from-exporting-at-config-level # noqa:E501\n    _content: Optional[AnyStr] = PrivateAttr(None)\n    # If the content is of type bytes\n    is_bytes: bool = False\n\n    @property\n    def basename(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return os.path.basename(self.path)\n\n    @property\n    def dirname(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return os.path.dirname(self.path)\n\n    @property\n    def extension(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n        return self.basename.split(\".\")[-1]\n\n    @property\n    def content(self) -&gt; AnyStr:\n\"\"\"Return the content of the file.\n\n        Returns:\n            The content of the file.\n\n        Raises:\n            FileContentNotLoadedError: if the content is not yet loaded.\n        \"\"\"\n        if self._content is None:\n            raise FileContentNotLoadedError(\n                \"The content of the file has not been loaded yet.\"\n            )\n        return self._content\n</code></pre>"},{"location":"reference_models/#repository_orm.model.File.basename","title":"<code>basename()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef basename(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return os.path.basename(self.path)\n</code></pre>"},{"location":"reference_models/#repository_orm.model.File.content","title":"<code>content()</code>  <code>property</code>","text":"<p>Return the content of the file.</p> <p>Returns:</p> Type Description <code>AnyStr</code> <p>The content of the file.</p> <p>Raises:</p> Type Description <code>FileContentNotLoadedError</code> <p>if the content is not yet loaded.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef content(self) -&gt; AnyStr:\n\"\"\"Return the content of the file.\n\n    Returns:\n        The content of the file.\n\n    Raises:\n        FileContentNotLoadedError: if the content is not yet loaded.\n    \"\"\"\n    if self._content is None:\n        raise FileContentNotLoadedError(\n            \"The content of the file has not been loaded yet.\"\n        )\n    return self._content\n</code></pre>"},{"location":"reference_models/#repository_orm.model.File.dirname","title":"<code>dirname()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef dirname(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return os.path.dirname(self.path)\n</code></pre>"},{"location":"reference_models/#repository_orm.model.File.extension","title":"<code>extension()</code>  <code>property</code>","text":"<p>Return the name of the file.</p> Source code in <code>repository_orm/model.py</code> <pre><code>@property\ndef extension(self) -&gt; str:\n\"\"\"Return the name of the file.\"\"\"\n    return self.basename.split(\".\")[-1]\n</code></pre>"},{"location":"repositories/","title":"Data Repositories","text":"<p>Data repositories give a common interface to store the models in databases.</p>"},{"location":"repositories/#usage","title":"Usage","text":"<p>The different repositories share the next operations:</p> <code>add</code> Add an <code>Entity</code> object or list of <code>Entity</code> objects to the repository, if it already exist, it updates the stored attributes. If you want to merge the entities before adding them to the repository, use the <code>merge=True</code> argument. <code>delete</code> Remove an <code>Entity</code> object form the repository. <code>get</code> Obtain an <code>Entity</code> from the repository by it's ID. Optionally you can pass the <code>attribute</code> argument if you want to filter by other than the <code>id_</code>, remember that only one attribute can be returned, so the chosen attribute should uniquely identify the entity. <code>commit</code> Persist the changes into the repository. <code>all</code> Get all the entities of a type or types from the repository. If no argument is given, it will return all entities. <code>search</code> Get the entities whose attributes match a condition or regular expression. <code>first</code> Get the first entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. <code>last</code> Get the last entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. <code>apply_migrations</code> Run the migrations of the repository schema. <code>close</code> Close the connection to the database. <code>is_close</code> Property that tells if the connection to the database is closed. <code>empty</code> Remove all the entities from the repository. <p>Changes in the repository aren't persisted until you run <code>repo.commit()</code> (with the exception of <code>empty</code> and <code>apply_migrations</code>).</p>"},{"location":"repositories/#repositories","title":"Repositories","text":"<p>To change the repository you only need to change the url passed to <code>load_repository</code>. We have the next repositories:</p> <ul> <li>FakeRepository: is the simplest implementation of the     repository pattern, meant to be used for the tests and early phases of     development.</li> <li>TinyDBRepository: is the implementation of the     repository pattern for the local NoSQL     TinyDB database. You     can use it in the early stages of the project where the data schema is yet     unstable and you don't have enough entities to have performance issues.</li> <li>PypikaRepository: is the implementation of the     repository pattern for the relational databases. It's meant for the stages     of the project where the schema is more stable and you need the improved     performance of these types of databases.</li> </ul>"},{"location":"testing/","title":"Testing","text":"<p>Testing your code is a hated but good practice. Repository ORM tries to make your testing experience less cumbersome.</p> <p>You can use different strategies depending on the level of testing. For unit and integration tests the <code>FakeRepository</code> may be your best option, for end-to-end ones, I'd use <code>TinyDBRepository</code>.</p>"},{"location":"testing/#unit-and-integration-tests","title":"Unit and integration tests","text":"<p>Unit tests are meant to test individual units of code, for example, a function or a method of a class. You'll probably use them to test your models or services.</p> <pre><code>import pytest\n\nfrom repository_orm import Entity, FakeRepository, Repository\n\n\n@pytest.fixture()\ndef repo() -&gt; FakeRepository:\n    return FakeRepository()\n\n\nclass Author(Entity):\n    first_name: str\n\n\ndef create_greeting(repo: Repository, author_id: int) -&gt; str:\n    author = repo.get(author_id, Author)\n    return f\"Hi {author.first_name}!\"\n\n\ndef test_greetings(repo: FakeRepository) -&gt; None:\n    author = Author(id_=20, first_name=\"Brandon\")\n    repo.add(author)\n    repo.commit()\n\n    result = create_greeting(repo, 20)\n\n    assert result == \"Hi Brandon!\" # noqa\n</code></pre>"},{"location":"testing/#end-to-end-tests","title":"End-to-end tests","text":"<p>End-to-end tests evaluate the whole functionality of the program from the eyes of the user. For example, testing a command line or the API endpoint. Usually the program loads the repository from storage at start time, which means that the FakeRepository can't be used.</p> <p>We're going to create a click command line program called <code>greet</code> that once it's called, it will return the first author in the repository. It's a little bit more complex but bare with me.</p> <pre><code>from pathlib import Path\nfrom typing import Generator\n\nimport click\nimport pytest\nfrom click.testing import CliRunner\n\nfrom repository_orm import Entity, Repository, TinyDBRepository, load_repository\n\n\n# Model\nclass Author(Entity):\n    first_name: str\n\n\n# Fixtures\n@pytest.fixture(name=\"db_tinydb\")\ndef db_tinydb_(tmp_path: Path) -&gt; str:\n    tinydb_file_path = str(tmp_path / \"tinydb.db\")\n    return f\"tinydb:///{tinydb_file_path}\"\n\n\n@pytest.fixture()\ndef repo(db_tinydb: str) -&gt; Generator[TinyDBRepository, None, None]:\n    repo = TinyDBRepository(database_url=db_tinydb)\n\n    yield repo\n\n    repo.close()\n\n\n# Service\ndef create_greeting(repo: Repository) -&gt; str:\n    first_author = repo.all(Author)[0]\n    return f\"Hi {first_author.first_name}, you're the first author!\"\n\n\n# Entrypoint\n@click.command()\n@click.argument(\"database_url\")\ndef greet(database_url: str) -&gt; None:\n    repo = load_repository(database_url)\n\n    print(create_greeting(repo))\n\n    repo.close()\n\n\n# Test\ndef test_greetings(repo: TinyDBRepository, db_tinydb: str) -&gt; None:\n    author = Author(id_=20, first_name=\"Brandon\")\n    repo.add(author)\n    repo.commit()\n    runner = CliRunner()\n\n    result = runner.invoke(greet, [db_tinydb])\n\n    assert result.exit_code == 0\n    assert result.output == \"Hi Brandon, you're the first author!\\n\" # noqa\n</code></pre> <p>First we define the fixtures, we start with <code>db_tinydb</code> that uses the pytest's <code>tmp_path</code> fixture to create a random temporal directory and then sets the database url. The <code>repo</code> fixture uses that database url to create a <code>TinyDBRepository</code> instance.</p> <p>The model <code>Author</code> and service <code>create_greeting</code> are similar to the previous section.</p> <p>The entrypoint is where we define the command line interface, in this case the command is going to be called <code>greet</code> and it's going to accept an argument called <code>database_url</code>, it will initialize the repository and use the <code>create_greeting</code> to show the message to the user through the terminal.</p> <p>To test this code, we first need to add an Author, so the function can look for it. We do it in the first three lines of <code>test_greetings</code>. Then we initialize the <code>runner</code> which simulates a command line call, and we make sure that the program exited well, and gave the output we expected.</p>"},{"location":"tinydb_repository/","title":"TinyDBRepository","text":"<p>The <code>TinyDBRepository</code> is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues.</p> <p>It stores the persisted Entities into a json file.</p> <p>Load it with:</p> <pre><code>from repository_orm import load_repository\n\nrepo = load_repository('tinydb://path/to/database.db')\n</code></pre>"},{"location":"tinydb_repository/#features","title":"Features","text":"<p>Follow the overview example to see how to use each method.</p> <code>add</code> Appends the <code>Entity</code> object to the default table by translating its attributes to a valid json row. If it already exists, it uses the upsert statement to update it's attributes in the table. <code>delete</code> Deletes the <code>Entity</code> object from the collection by searching the row that matches the object ID. <code>get</code> Obtain an <code>Entity</code> by extracting the row that matches the ID and build the <code>Entity</code> object with that data. <code>commit</code> Persist the changes into the database. <code>all</code> Obtain all the entities of type <code>Entity</code>. Similar to the <code>get</code> method but for all entities. <code>search</code> Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. <code>apply_migrations</code> We don't yet support migrations on the schema, so the models should be flexible enough to absorb the changes, or you can code your migrations in your program, or even better, help us solve #27."},{"location":"tinydb_repository/#internal-workings","title":"Internal workings","text":"<p>This section is meant for the people that you to expand the functionality of the TinyDBRepository. It explains how it works under the hood.</p> <p>Once the object is initialized with the database url with the format <code>tinydb:///path_to_database_file</code>, an <code>TinyDB</code> object is created in the <code>db_</code> attribute, the path to the database is saved in <code>database_file</code> and a empty dictionary of staged changes is created in <code>staged</code>.</p>"},{"location":"tinydb_repository/#saving-entities","title":"Saving entities","text":"<p>All entities are saved in the same default table <code>_default</code>, to avoid <code>id_</code> collision, before storing the objects, an <code>model_type_</code> attribute is appended with the lowercase name of the entity class. When retrieving objects with <code>get</code> and <code>all</code>, the attribute is deleted.</p>"},{"location":"tinydb_repository/#committing","title":"Committing","text":"<p>TinyDB doesn't have the concept of transactions, the tinyrecord plugin does, but you need to run everything in the same context manager, which doesn't suit our case. So whenever we <code>add</code> or <code>remove</code> an entity from the repository, they are stored in the <code>staged</code> attribute, and once <code>commit</code> is called, they are persisted into the database.</p>"},{"location":"tinydb_repository/#references","title":"References","text":"<ul> <li>TinyDB documentation</li> </ul>"},{"location":"adr/001-entity_id_definition/","title":"001: Entity id_ definition","text":""},{"location":"adr/001-entity_id_definition/#status","title":"Status","text":"<p>Superseeded</p> <p>It has been partially superseeded by 002</p> <p>String ids are again supported.</p>"},{"location":"adr/001-entity_id_definition/#context","title":"Context","text":"<p>Right now the <code>Entity</code> class has a mandatory <code>id_</code> attribute of types <code>str</code> or <code>int</code>. That prevents the user to create entities a model level as they are not aware of the existent entities in the repository.</p>"},{"location":"adr/001-entity_id_definition/#proposals","title":"Proposals","text":"<p>We can:</p> <ul> <li>Assume that the model functions that create the new entities receive the     new entity id as an argument.</li> <li>Change the definition of the <code>id_</code> attribute so that it can be set by the     repository at the moment of adding it to the repository.</li> </ul> <p>I've started using the first in pydo and found it cumbersome.</p> <p>The first approximation for the second can be to assume that the <code>id_</code> is an integer, by default is set to a negative value, marking it as invalid, and when the repository sees it, gets the last id and increments it in a unit.</p> <p>This can't be easily done if the <code>id_</code> is a <code>str</code>. So I'm temporarily dropping support for this types of IDs. If anyone needs them, we can create a workaround like converting them to an ascii integer and increasing it by one.</p> <p>If we want more complex objects to be used as ids, we may think of letting the user specify a callable to increase the ids.</p>"},{"location":"adr/001-entity_id_definition/#decision","title":"Decision","text":"<p>We're setting a default <code>id_</code> value of <code>-1</code> on Entities, the repository will react to these ids, getting the last valid ID and increasing it by one.</p>"},{"location":"adr/001-entity_id_definition/#consequences","title":"Consequences","text":"<p>As a side effect, we're temporarily dropping support for <code>str</code> <code>id_</code> attributes.</p>"},{"location":"adr/002-support_string_ids/","title":"002: String id_ support","text":""},{"location":"adr/002-support_string_ids/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/002-support_string_ids/#context","title":"Context","text":"<p>In version 0.3.0 we dropped support for string ids, and that was a bad decision, as there are already projects that use it.</p> <p>The reason of deprecation was because the new feature to auto increment the ID of the entities that hadn't set it, wasn't \"easy\" to implement for strings.</p>"},{"location":"adr/002-support_string_ids/#proposals","title":"Proposals","text":"<p>Restore the support for string ids, but without the auto increment feature. If you're using string ids is probably because you have an id generator or you're getting them from outside sources.</p>"},{"location":"adr/002-support_string_ids/#decision","title":"Decision","text":""},{"location":"adr/002-support_string_ids/#consequences","title":"Consequences","text":""},{"location":"adr/003-make_entity_models_optional_arguments/","title":"003: Make entity_models optional arguments","text":""},{"location":"adr/003-make_entity_models_optional_arguments/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/003-make_entity_models_optional_arguments/#context","title":"Context","text":"<p>Some applications need to do operations on all or a subset of entity types in the repository, for example for the <code>get</code>, <code>search</code>, <code>all</code>, <code>first</code> or <code>last</code>.</p> <p>Right now the <code>entity_model</code> is a mandatory argument for these methods, that means that the code calling the repository needs to be aware of all the entity models inside the repository and call the methods for each of them.</p>"},{"location":"adr/003-make_entity_models_optional_arguments/#proposals","title":"Proposals","text":"<p>To solve it, we should change the <code>entity_model</code> an argument to a more flexible type <code>Union[Type[Entity], List[Type[Entity]], None]</code>. That change carries some side effects:</p> <ul> <li>We need to add logic at repository level to process one, a subset or all the     entity types.</li> <li>Some repositories (tinydb and pypika) used the <code>entity_model</code> to build the     entity, if it's not specified, we need to build the logic that lets them     build the entities from their data.</li> <li>The calls to the methods without specifying the <code>entity_model</code> can have     a worse performance.</li> </ul>"},{"location":"adr/003-make_entity_models_optional_arguments/#build-the-entities-from-their-data","title":"Build the Entities from their data","text":"<p>To build the entities from the data we need those methods to be able to link that data to a model type, we can either:</p> <ul> <li>Delegate that functionality to the application using the repository.</li> <li>Configure the repositories in a way that we can deduce the model from the data     stored in itself.</li> </ul> <p>The first solution means that each application will need to implement and maintain that code, which will lead to more maintenance and duplicated code, but a simpler repository configuration.</p> <p>The second solution will mean that the code for the methods is more complex and/or the repository initialization needs more arguments.</p> <p>We already store the key information that tells which model does the data belong to. In the tinydb repo it's stored as an attribute <code>_model_type</code>, and in the pypika repo is stored as tables names. The fake repo doesn't have this problem.</p> <p>If we initialize the repository with a <code>models</code> optional argument, with a list of the entity models, we can create an internal <code>models</code> attribute that holds a dictionary with the key equal to the value stored in the repos, and the value the model type. If the user doesn't provide this argument at repo initialization, it will be supposed that it will give the <code>entity_model</code> on each of the repo methods that require it, otherwise an error will be shown.</p>"},{"location":"adr/003-make_entity_models_optional_arguments/#performance-loss","title":"Performance loss","text":"<p>The <code>entity_model</code> acted as a filter on the amount of data to perform the operations, if the user doesn't specify it, the repo needs to work with more data and therefore be slower. Maybe some of the methods like <code>all</code>, <code>first</code>, or <code>last</code> will work faster on some repositories based on how they or their libraries work, but the <code>get</code> and <code>search</code> will definitely go slower.</p> <p>In the case of <code>get</code> we can mitigate it with an optional callable argument that can run regexps on the id to select the subset of entity models that contain id's of that type.</p>"},{"location":"adr/003-make_entity_models_optional_arguments/#decision","title":"Decision","text":"<p>Change the signatures of the <code>get</code>, <code>search</code>, <code>all</code>, <code>first</code> and <code>last</code> methods to accept one, many or no <code>Entity</code> subclasses. If none is given, it will assume that the repository was initialized with the <code>models</code> argument, where the user gives the repo the model of the data it holds.</p> <p>For the sake of cleanness, we're renaming <code>entity_models</code> for <code>models</code> in the function arguments.</p>"},{"location":"adr/003-make_entity_models_optional_arguments/#consequences","title":"Consequences","text":"<p>The change makes the library more usable while it retains the performance of the previous code base.</p> <p>Two breaking changes were introduced though:</p> <ul> <li>The argument <code>entity_model</code> is no longer the first one for the methods <code>get</code>     and <code>search</code>, but the second.</li> <li>The argument <code>database_url</code> is no longer the first argument in the     <code>load_repository</code> function, but the second, being the first the <code>models</code>.</li> </ul>"},{"location":"adr/004-add_complex_queries/","title":"004: Add complex queries","text":""},{"location":"adr/004-add_complex_queries/#status","title":"Status","text":"<p>Draft</p>"},{"location":"adr/004-add_complex_queries/#context","title":"Context","text":"<p>Right now the <code>search</code> method only allows a dictionary of keys that the objects must match, this way of selecting objects has become insufficient for the programs that use the library forcing them to extract from the repository a greater subset of objects that contain a serie of attributes and then do another filtering afterwards. This is the case for example when the user wants to select objects that:</p> <ul> <li>Have a datetime or integer greater or smaller than an amount.</li> <li>Don't have an attribute with a defined value</li> <li>Match a combination of criteria, for example:<ul> <li>Have an attribute with a value and another that is greater than X</li> <li>Have an attribute with a value and another that doesn't contain the value     Y.</li> </ul> </li> <li>Match a criteria on a related object (<code>JOIN</code> operations).</li> </ul> <p>This schema has the next disadvantages:</p> <ul> <li>The user is constrained to a very basic query type</li> <li>The repository returns more objects than the user needs, so more traffic is     sent between the application and the database</li> <li>The user needs to do an extra filter afterwards. This is a bad idea because     doing the filtering at databases level probably gives better performance     and the user needs to write more code than necessary.</li> </ul>"},{"location":"adr/004-add_complex_queries/#proposals","title":"Proposals","text":"<p>Change the way we let the user specify the criteria that it wants to search so that it can do more powerful searches. I can think of two ways of doing this:</p> <ul> <li>Writing the query in a string and parsing it afterwards.</li> <li>Writing the query with a query builder.</li> </ul> <p>Given this analysis, the query builder system looks better.</p>"},{"location":"adr/004-add_complex_queries/#query-builder","title":"Query builder","text":"<p>We will create a <code>Query</code> object that follows the theory of query builders.</p> <p>Right now queries make sense only to extract data from the database, so speaking in SQL terms, only <code>SELECT</code> and <code>DELETE</code> queries are interesting for us. To do a select query you need:</p> <ul> <li>The table to extract data from</li> <li>The fields to extract</li> <li>The condition to select the rows</li> <li>The sorting method of the results</li> <li>The number of results to return</li> </ul> <p>All of the <code>Query</code> methods return <code>self</code> in order to be able to construct it with chained methods and properties. Those methods that don't need an argument will be coded as properties to save keystrokes on unneeded <code>()</code>.</p>"},{"location":"adr/004-add_complex_queries/#table-to-extract-data-from","title":"Table to extract data from","text":"<p>Applied to the <code>repository_orm</code> usage, the <code>FROM</code> is defined by the model class both to extract the table name, build the end objects and let the type checker know what type of objects it's returning, so we need to pass the class of the model to the <code>search</code> and <code>all</code> methods. It makes sense then to pass the argument at initialization time of the <code>Query</code> object.</p>"},{"location":"adr/004-add_complex_queries/#fields-to-extract","title":"Fields to extract","text":"<p>In our case it doesn't make sense to let the user select the fields it wants to extract, as we return built objects and not just the values of the rows.</p>"},{"location":"adr/004-add_complex_queries/#condition-to-select-the-objects","title":"Condition to select the objects","text":""},{"location":"adr/004-add_complex_queries/#simple-query-operators","title":"Simple query operators","text":"<p>Assuming that <code>query = Query(Model)</code> there are the next methods to select the data, it will return the objects if:</p> <ul> <li><code>equal</code>: Attribute match value.</li> <li><code>not_equal</code>: Attribute doesn't match value.</li> <li><code>greater</code>: Attribute is greater than value.</li> <li><code>greater_or_equal</code>: Attribute is greater or equal than value.</li> <li><code>smaller</code>: Attribute is smaller than value.</li> <li><code>smaller_or_equal</code>: Attribute is smaller or equal than value.</li> </ul> <p>To act on one attribute and one value you can use <code>query.method(attribute, value)</code>, for example <code>query.equal('id_', 3)</code>. To act on many attributes you can use <code>query.method({attribute1: value1, attribute2: value2})</code>, for example <code>query.greater({'rating': 3, 'created_at': datetime.datetime.now()})</code>.</p>"},{"location":"adr/004-add_complex_queries/#query-composition","title":"Query composition","text":"<p>If you concatenate methods and properties on a query they are supposed to be conditions that all objects must match.</p>"},{"location":"adr/004-add_complex_queries/#or","title":"OR","text":"<p><code>or</code> can be used to match one or many conditions but not others. You have to select two types of criteria, so you need to <code>Query</code> objects.</p> <p><code>query.greater('rating', 3).or(Query().smaller('rating', 1))</code></p> <p>Note that if the second <code>Query</code> isn't initialized with a model, it will be assumed to be the same as the first one.</p>"},{"location":"adr/004-add_complex_queries/#and","title":"AND","text":"<p><code>and</code> can be used if you want to select different criteria for different objects:</p> <pre><code>Query(Book).greater('rating', 3).and(Query(Author).equal('id_', 1))\n</code></pre>"},{"location":"adr/004-add_complex_queries/#join","title":"Join","text":"<p><code>join</code> can be used to match entities if an entity that is related to them matches one or many condition, for example to get all the books of the author whose <code>id</code> is <code>1</code> you can:</p> <pre><code>Query(Book).join(Query(Author).equal('id_', 1))\n</code></pre>"},{"location":"adr/004-add_complex_queries/#sorting-the-results","title":"Sorting the results","text":"<p>By default the results are sorted by <code>id_</code> increasingly, to sort by other criteria use the <code>sort</code> method.</p> <pre><code>query.sort('rating')\n</code></pre> <p>To reverse the order of the sorting use the <code>reverse</code> argument:</p> <pre><code>query.sort('rating', reverse=True)\n</code></pre> <p>To order by many criteria chain <code>sort</code> methods, for example if you want to sort by <code>rating</code> and then by <code>created_date</code> you can use:</p> <pre><code>query.sort('rating').sort('created_date')\n</code></pre>"},{"location":"adr/004-add_complex_queries/#number-of-results","title":"Number of results","text":"<p>By default all results are returned, if you want to receive only a limited amount use the <code>limit</code> method</p> <pre><code>query.limit(10)\n</code></pre>"},{"location":"adr/004-add_complex_queries/#delete-queries","title":"Delete queries","text":"<p>Right now the <code>delete</code> method allows only one or many entities, we can change the signature so that it also allows a <code>Query</code> object that can tweak the delete query instead of just using the <code>id_</code>.</p>"},{"location":"adr/004-add_complex_queries/#decision","title":"Decision","text":"<p>Implement the proposed solution, adding a <code>UserWarning</code> on the old method until we deprecate it.</p>"},{"location":"adr/004-add_complex_queries/#consequences","title":"Consequences","text":"<p>Pros:</p> <ul> <li>We'll improve a lot the extraction of information from the repo</li> </ul> <p>Cons:</p> <p>Users will need to change their code:</p> <ul> <li>How they query the repositories.</li> </ul>"},{"location":"adr/005-simplify_search_and_all_signature/","title":"005: Simplify search and all signature","text":""},{"location":"adr/005-simplify_search_and_all_signature/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/005-simplify_search_and_all_signature/#context","title":"Context","text":"<p>Right now we raise an <code>EntityNotFoundError</code> exception if <code>search</code> returns no results, which forces the user to catch this exception when it makes more sense to return an empty list as these methods are usually used on loops.</p> <p>We're also having some issues with the types of the return values of these methods as we allowed them to be of type <code>Union[Type[Entity], List[Type[Entity]], None]</code> since 003, both when writing the code as the type hints are difficult to write and debug and also when doing operations on the returned objects, as the returned list contains objects with different models that as they have different attributes and objects they need to be dealt differently. This last point means that the user has to split the results using <code>isinstance</code> at some point.</p> <p>Using many models in <code>get</code> is only a good idea when you're sure that id's are unique across all models, that way you can do <code>repo.get(id, models)</code> and get the only entity that matches, when we initialized the repository with the available models, you could go even further and only use <code>repo.get(id)</code>. This has the next disadvantages:</p> <ul> <li>The current code requires that each repository needs to implement the logic     of:<ul> <li>Dealing with many models, which we want to remove. It could be delegated     to <code>get</code> at <code>abstract.py</code> level and make <code>_get</code> only accept one model.</li> <li>What happens when more than one entity is found. This could be mitigated if     we change the signature of <code>_get</code> to always return a <code>List[Entity]</code> and do     the checking at <code>get</code> level in <code>abstract.py</code>.</li> </ul> </li> <li>You don't know the type of the returned object at type checker level. It's     a nuisance but not critical, as it should be acceptable if you're using     <code>get</code> this way.</li> </ul> <p>The <code>last</code> and <code>first</code> methods are used over the <code>all</code> method not over the <code>search</code> which would be useful too.</p>"},{"location":"adr/005-simplify_search_and_all_signature/#proposals","title":"Proposals","text":""},{"location":"adr/005-simplify_search_and_all_signature/#return-a-list-instead-of-exception","title":"Return a list instead of exception","text":"<p><code>search</code> will return an empty list if there are no results instead of an <code>EntityNotFoundError</code> exception.</p>"},{"location":"adr/005-simplify_search_and_all_signature/#only-allow-one-model-in-search-and-all","title":"Only allow one model in search and all","text":"<p>We could revert 003 and only allow one model in <code>search</code> and <code>all</code> but that will mean that the context of that ADR won't be met anymore which was that some applications need to do operations on all or a subset of entity types. They will then be forced to run the desired method once for each entity type which has the next disadvantages:</p> <ul> <li> <p>The user has to write more code. Which may not true, as even though you     have to run <code>repo.search</code> and <code>repo.all</code> more than once, right now you also     have to write additional code to tell apart the returned objects. This last     statement may not be true if the user has asked for a group of entities that     share some common attributes with whom it wants to work with.</p> <p>After migrating some code I've seen that at user level the change is from:</p> <pre><code>active_resources = repo.search({\"state\": \"active\"}, models)\n</code></pre> <p>To:</p> <pre><code>active_resources = [\n    entity for model in models for entity in repo.search({\"state\": \"active\"}, model)\n]\n</code></pre> <p>Which I think it's assumable given that it can be considered a corner case.</p> </li> <li> <p>Instead of running everything on a query, many will be done. The potential     downside of that is performance loss, but in reality:</p> <ul> <li>The pypika and fake repos are already doing many queries.</li> <li>The tinydb repo is doing everything in one query but then from the     gathered data it has to go model by model building the ones that match.</li> </ul> <p>So probably we won't have any performance loss.</p> </li> </ul> <p>And the next advantages:</p> <ul> <li>We've introduced a great deal of complexity on     003 both on functions and     type hints, removing them will improve maintainability and peace of mind     when coding.</li> </ul>"},{"location":"adr/005-simplify_search_and_all_signature/#only-allow-one-model-in-get","title":"Only allow one model in get","text":"<p>If we only allow one model in <code>get</code> we'll remove complexity in terms of:</p> <ul> <li>No need to loop over the models.</li> </ul> <p>The management of the case of more than one entity found has to be still managed, as we can only enforce this case in pypika, fake and tinydb doesn't have that kind of constrain at database level.</p> <p>The case that it makes sense to keep the feature is a corner case as most of databases use integer ids. And if you've made the ids unique between models it should be straight forward to make a function that gives you the model for that ID, or you're free to iterate over the models and suppress the <code>EntityNotFoundError</code> exception.</p> <p>Therefore it makes no sense to keep complexity for a corner case.</p>"},{"location":"adr/005-simplify_search_and_all_signature/#leave-last-and-first-as-they-are","title":"Leave last and first as they are","text":"<p>Even though it's true that they could be used on the <code>search</code> result, let's be honest, using <code>[0]</code> and <code>[-1]</code> is not that difficult, and if there are no elements it will return an <code>IndexError</code> a common used exception. As <code>first</code> and <code>last</code> are already coded and it's easy to maintain I'll leave them as they are and assume that <code>search</code> won't have them.</p> <p>After a deeper analysis, <code>last</code> and <code>fist</code> take into account both staged and stored entities, so it's not equal to <code>[0]</code> and <code>[-1]</code>.</p>"},{"location":"adr/005-simplify_search_and_all_signature/#decision","title":"Decision","text":"<ul> <li>Revert the changes of 003.</li> <li><code>search</code> will return an empty list if there are no results instead of     an <code>EntityNotFoundError</code> exception.</li> </ul>"},{"location":"adr/005-simplify_search_and_all_signature/#consequences","title":"Consequences","text":"<p>Pros:</p> <ul> <li> <p>More maintainable code.</p> <ul> <li>Less complexity in the data adapters.</li> <li>Less problems with the type hints.</li> </ul> </li> <li> <p>Remove the model conflicts of <code>get</code></p> </li> </ul> <p>Cons:</p> <ul> <li>Users will need to update their code as the signature of <code>get</code>, <code>all</code>,     <code>search</code>, <code>first</code>, and <code>last</code> will change.</li> </ul> <p>The users will have 3 months to do the changes.</p>"},{"location":"adr/005-simplify_search_and_all_signature/#implementation","title":"Implementation","text":""},{"location":"adr/005-simplify_search_and_all_signature/#on-2022-06-10","title":"On 2022-06-10","text":"<ul> <li>Change the signature of <code>__init__</code> of the repositories to remove the <code>models</code>     argument.</li> <li>Change the signature of <code>get</code>, <code>all</code>, <code>search</code>, <code>first</code>, <code>last</code>, in <code>adapters/data/abstract.py</code> by:<ul> <li>Simplifying the <code>models</code> signature from <code>OptionalModelOrModels</code> to     <code>Optional[Type[Entity]]</code>.</li> <li>Add the <code>model</code> argument with temporal signature <code>Optional[Type[Entity]]</code>     in the ordered position of <code>models</code> so that users that are using     positional arguments start using this variable. The <code>Optional</code> signature     is there in case users are using the named argument <code>models</code> instead of     by position, but in the end it will become <code>Type[Entity]</code>.</li> </ul> </li> </ul>"},{"location":"adr/005-simplify_search_and_all_signature/#on-2022-12-10","title":"On 2022-12-10","text":"<p>We didn't plan well the migration, as we still have an argument called <code>models</code> when we only support one model! Now we need to do another migration in case that users are using this named argument, instead of position arguments.</p> <ul> <li> <p>Change the signature of <code>__init__</code> of the repositories to remove the     <code>search_exception</code> transition argument.</p> </li> <li> <p>Change the signature of <code>get</code>, <code>all</code>, <code>search</code>, <code>first</code>, <code>last</code>, in <code>adapters/data/abstract.py</code> by:</p> <ul> <li>Removing the <code>models</code> argument.</li> <li>Simplifying the <code>model</code> argument signature to <code>Type[Entity]</code>.</li> </ul> </li> <li> <p>Change the signature of <code>load_repository</code> of <code>services.py</code> to remove <code>models</code>     and <code>search_exception</code>.</p> </li> </ul>"},{"location":"adr/006-drop_again_string_ids/","title":"006: Drop support for string IDs","text":""},{"location":"adr/006-drop_again_string_ids/#status","title":"Status","text":"<p>Draft</p>"},{"location":"adr/006-drop_again_string_ids/#context","title":"Context","text":"<p>Supporting string IDs has made the source code more complex because it:</p> <ul> <li>We have to handle each case <code>str</code>, and <code>int</code> independently.</li> <li>The signature of the functions is more complex.</li> <li><code>str</code> ids don't have the auto-increment feature.</li> </ul> <p>On the other hand, string IDs are useful when the identifying property of an entity is a string. This gives two benefits:</p> <ul> <li>You can <code>repo.get</code> by that element.</li> <li>You can't have two elements with the same attribute.</li> </ul>"},{"location":"adr/006-drop_again_string_ids/#proposals","title":"Proposals","text":"<p>We can try to simplify the ID signature to <code>int</code> only while giving the users tools so that they don't loose the benefits of the <code>str</code> IDs.</p> <ul> <li>We already added an optional argument to <code>repo.get</code> so that you can get by     another attribute. This way it would be easy to spot what attributes would     need their own index.</li> <li>We'll need to support uniqueness of entities based on an attribute other than     <code>id_</code>. (We need to refine this idea.)</li> </ul>"},{"location":"adr/006-drop_again_string_ids/#decision","title":"Decision","text":""},{"location":"adr/006-drop_again_string_ids/#consequences","title":"Consequences","text":""},{"location":"adr/007-support_derived_entities/","title":"007 support derived entities","text":""},{"location":"adr/007-support_derived_entities/#status","title":"Status","text":"<p>Draft</p>"},{"location":"adr/007-support_derived_entities/#context","title":"Context","text":"<p>There are some cases where the current use of the entities falls short:</p> <ul> <li>When a service updates part of the attributes of an entity.</li> <li>When an entrypoint accepts part of the attributes of an entity.</li> <li>When an entrypoint returns an entity plus some added attributes.</li> </ul>"},{"location":"adr/007-support_derived_entities/#service-updates-part-of-the-attributes-of-an-entity","title":"Service updates part of the attributes of an entity","text":"<p>Imagine that we have an entity that has two attributes, one is retrieved from an external API and changes over the time, the second is given by the user at creation time and it doesn't change over the time:</p> <pre><code>class Author(Entity):\n    number_of_books: int\n    added_at: datetime\n</code></pre> <p>If we have a service called <code>get_author_books</code> that gets the <code>number_of_books</code> of an author, it needs to build a valid <code>Author</code> object so that it's able to <code>repo.add()</code> it to persist the changes. The problem is that <code>added_at</code> is a required attribute that was filled the first time we created the <code>Author</code> object. But successive calls to <code>get_author_books</code> don't need to touch this attribute, it only needs to update the <code>number_of_books</code>.</p> <p>To solve this we can:</p> <ul> <li> <p>Make <code>added_at</code> signature as <code>Optional[datetime] = None</code>, so that we don't     need to fill up this attribute, and use the <code>merge</code> mode of <code>repo.add()</code>     that won't update the value of the stored entity for all attributes that     were not explicitly set.</p> <p>The problem with this approach is that we don't want <code>added_at</code> to be <code>None</code> for the rest of the program, so we would be tweaking the types of the model to be able to update part of the model, but actually we will be breaking the expected model signature.</p> </li> <li> <p>Create a function that <code>repo.get()</code> the entity we want to update, update the     value and <code>repo.add()</code> it back.</p> <p>This has the downsides that the types of that function don't reflect the</p> </li> </ul> <p>[Task] Idea de repository orm, a\u00f1adir el metodo merge, que acepte id, entity y objeto de update, donde ese objeto esta creado por un servicio y su clase es un subconjunto de los atributos de la clase del entity.</p> <p>De manera que la mergeabilidad no es solo entre objetos de la misma clase, sino que por objetos con los mismos atributos.</p> <p>Lo way seria crear esa clase derivada a partir de la clase que representa mediante el borrado de los fields que no necesite y el a\u00f1adido de fields que le faltan, como muestra este issue</p> <p>https://github.com/samuelcolvin/pydantic/issues/830</p> <p>https://github.com/samuelcolvin/pydantic/issues/1937</p> <p>https://stackoverflow.com/questions/15247075/how-can-i-dynamically-create-derived-classes-from-a-base-class</p> <p>Quiza no hace falta a\u00f1ador el merge, quiza se pueda usar add(update_object, Entity), y que sea suficientemente inteligente como para hacer el merge</p> <p>A lo mejor si hace falta un metodo distinto, ya que es probable que el objeto derivado no sepa el id del objeto a actualizar, sino que el merge sea en funcion de otra propiedad, entonces seria repo.merge(authir_up</p> <p>Para persistir objetos, la clase derivada deberia usar solo un sibconjunto de la clase original. Pero para output de respuestas de entrypoints, si podria ser interesante devolver informaci\u00f3n procesada adicional</p> <p>El modo de derivar clases es con el create_model, mirar la docu</p> <p>https://pydantic-docs.helpmanual.io/usage/models/#dynamic-model-creation</p> <p>Y el codigo fuente</p> <p>https://github.com/samuelcolvin/pydantic/blob/81b13ff3b4f67560dc1b5292ab5bb30e91276fd7/pydantic/main.py#L910</p> <p>A\u00f1ador fields es trivial a partir de la docu, quitarlos no tanto.</p> <p>Quiza se puede coger la.base class y acceder al atributo fields y annotations y en funcion de eso construir el argumento de create_model</p> <p>De ser asi, we can save the parent class in an internal attribute, so that add is able to understand it and we don't need to pass it as an extra argument. Then the signature would be</p> <p>add(entity: Union[DerivedEntity, Entity], merge_on: optional[str] = None)</p> <p>Where merge on will be the attribute name that get will use to fetch the parent entity to merge.</p> <p>If we pass a derived entity, the return value should be the updated entity, but that may be difficult to define as a signature</p> <p>https://stackoverflow.com/questions/60202691/python-typing-declare-return-value-type-based-on-function-argument</p> <p>https://docs.python.org/3/library/typing.html#typing.Protocol</p> <p>We can create derivedentity from basemodel, and when we use create_model, use it as base</p> <p>If we make the derivedentity a generic class that uses entity, the hints may work</p> <p>We need to handle the cases where the user uses a derived entity on the rest of the models (Use shortcuts or arrow keys)</p>"},{"location":"adr/007-support_derived_entities/#proposals","title":"Proposals","text":""},{"location":"adr/007-support_derived_entities/#deprecate-the-merge-mode-of-repoadd","title":"Deprecate the merge mode of repo.add()?????","text":"<p>TBD</p>"},{"location":"adr/007-support_derived_entities/#decision","title":"Decision","text":""},{"location":"adr/007-support_derived_entities/#consequences","title":"Consequences","text":""},{"location":"adr/008-migration-to-protocols/","title":"008 migration to protocols","text":""},{"location":"adr/008-migration-to-protocols/#status","title":"Status","text":"<p>Draft</p>"},{"location":"adr/008-migration-to-protocols/#context","title":"Context","text":"<p>We currently use Abstract classes to define the interface of the adapters, we also rely heavily on class inheritance. After reading hynek's subclassing in Python Redux I think using composition and Protocols will make the code cleaner, easier to read and to maintain.</p> <p>For example, we have an Abstract class <code>Repository</code> that defines both the interface and is used to share code between the implementations of the repositories. So we're mixing two types of subclassing, which is not a good idea. It's showing that there is some functionality that is common to all repositories and the implementation of each of them has to do only with the storage backend. To tell apart the repository methods and the implementations we're using an underscore, for example <code>def add(...)</code> is the repository that calls the <code>def _add(...)</code> that needs to be implemented by each of the particularizations. This is hard to read and understand.</p>"},{"location":"adr/008-migration-to-protocols/#proposals","title":"Proposals","text":""},{"location":"adr/008-migration-to-protocols/#use-the-storage-protocol","title":"Use the Storage Protocol","text":"<p>The idea is to create a <code>Repository</code> class that holds all the functionality of a repository, and extracting the storage functionality of each storage particularization to a <code>store</code> attribute whose interface is defined by a <code>Protocol</code>:</p> <pre><code>class Repository:\n    store: Storage\n</code></pre> <pre><code>class Storage(Protocol):\n\n    def add(self, entity: EntityT) -&gt; None: ...\n    def delete(self, entity: EntityT) -&gt; None: ...\n    def get(self,\n        value: EntityAttr,\n        model: Type[EntityT],\n        attribute: str = \"id_\",\n    ) -&gt; List[EntityT]: ...\n    def all(self, model: Type[EntityT]) -&gt; List[EntityT]: ...\n    def commit(self) -&gt; None: ...\n    def search(\n        self,\n        fields: Dict[str, EntityAttr],\n        model: Type[EntityT],\n    ) -&gt; List[EntityT]: ...\n    def apply_migrations(self, migrations_directory: str) -&gt; None: ...\n    def last(self, model:Type[EntityT]) -&gt; EntityT: ...\n    def first(self, model:Type[EntityT]) -&gt; EntityT: ...\n    def close(self) -&gt; None: ...\n\n    @property\n    def is_closed(self) -&gt; bool: ...\n\n    def empty(self) -&gt; None: ...\n</code></pre> <p>Where <code>EntityAttr</code> is each of the supported entity attributes.</p>"},{"location":"adr/008-migration-to-protocols/#implementation","title":"Implementation","text":""},{"location":"adr/008-migration-to-protocols/#entrypoint","title":"Entrypoint","text":"<p>I've thought of instead of using <code>load_repository</code> as an entrypoint, we could directly use <code>Repository('tinydb://...')</code> but then we'd need to import all the adapters into <code>model.py</code> which I think it's breaking the independence between components. Furthermore, if we keep the <code>load_repository</code> function we don't change the entrypoint for existent users.</p>"},{"location":"adr/008-migration-to-protocols/#storage-names","title":"Storage names","text":"<p>We can take the chance to change the name of the storages from the technology they use to the backend they use. I think this is more clear to users, which they won't care if we use TinyDB or other library to manage the resulting JSON but instead that the data is stored in JSON, therefore the next changes will be done:</p> <ul> <li><code>FakeRepository</code> -&gt; <code>MemoryStore</code></li> <li><code>TinyDBRepository</code> -&gt; <code>JSONStore</code></li> <li><code>PypikaRepository</code> -&gt; <code>SQLStore</code></li> </ul>"},{"location":"adr/008-migration-to-protocols/#decision","title":"Decision","text":""},{"location":"adr/008-migration-to-protocols/#consequences","title":"Consequences","text":""},{"location":"adr/adr/","title":"Architecture Decision Records","text":"<p>ADR are short text documents that captures an important architectural decision made along with its context and consequences.</p> <pre><code>graph TD\n    001[001: Entity ID definition]\n    002[002: Support String IDs]\n    003[003: Make entity_model optional arguments]\n    004[004: Add complex queries]\n    005[005: Simplify search and all signature]\n\n    click 001 \"https://lyz-code.github.io/repository-orm/adr/001-entity_id_definition/\" _blank\n    click 002 \"https://lyz-code.github.io/repository-orm/adr/002-support_string_ids/\" _blank\n    click 003 \"https://lyz-code.github.io/repository-orm/adr/003-make_entity_models_optional_arguments/\" _blank\n    click 004 \"https://lyz-code.github.io/repository-orm/adr/004-add_complex_queries/\" _blank\n    click 005 \"https://lyz-code.github.io/repository-orm/adr/005-simplify_search_and_all_signature/\" _blank\n\n    001 -- Partially superseeded --&gt; 002\n    003 -- Superseeded --&gt; 005\n\n    001:::superseeded\n    002:::accepted\n    003:::superseeded\n    004:::draft\n    005:::accepted\n\n    classDef draft fill:#CDBFEA;\n    classDef proposed fill:#B1CCE8;\n    classDef accepted fill:#B1E8BA;\n    classDef rejected fill:#E8B1B1;\n    classDef deprecated fill:#E8B1B1;\n    classDef superseeded fill:#E8E5B1;</code></pre>"}]}