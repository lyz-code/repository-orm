{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Library to ease the implementation of the repository pattern in python projects. Installing \u00b6 pip install repository-orm A Simple Example \u00b6 from repository_orm import Entity , load_repository class Author ( Entity ): first_name : str last_name : str country : str repo = load_repository ([ Author ]) author = Author ( first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( 0 ) assert brandon == author # Search entities brandon = repo . search ({ \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ()) == 0 # noqa Repository pattern theory \u00b6 The repository pattern is an abstraction over persistent storage, allowing you to decouple the model layer from the data layer. It hides the boring details of data access by pretending that all of our data is in memory. It has the following advantages: Give a simple interface, which you control, between persistent storage and our domain model. It's easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because the model is fully decoupled from the infrastructure. Writing the domain model before thinking about persistence helps focus on the problem at hand. If we need to change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later. Our database schema is simple because we have complete control over how we map our object to tables. Speeds up and makes more clean the business logic tests. It's easy to implement. But the following disadvantages: An ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postres if you ever need to. Maintaining ORM mappings by hand requires extra work and extra code. An extra layer of abstraction is introduced, and although we may hope it will reduce complexity overall, it does add complexity locally. Furthermore it adds the WTF factor for Python programmers who've never seen this pattern before. repository-orm aims to mitigate the last ones by: Supplying classes that already have the common operations for different storage solutions. Supplying test classes and fixtures so extending the provided repositories is easy. Usage \u00b6 The different repositories share the next operations: add Add an Entity object to the repository, if it already exist, it updates the stored attributes. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Get all the entities of a type or types from the repository. If no argument is given, it will return all entities. search Get the entities whose attributes match a condition or regular expression. first Get the first entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. last Get the last entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() . Repositories \u00b6 To change the repository you only need to change the url passed to load_repository . We have the next repositories: FakeRepository : is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. TinyDBRepository : is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. PypikaRepository : is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases. References \u00b6 As most open sourced programs, repository-orm is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . TinyDB Used to interact with the NoSQL database in the TinyDBRepository Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to repository-orm , see Contributing to repository-orm .","title":"Repository ORM"},{"location":"#installing","text":"pip install repository-orm","title":"Installing"},{"location":"#a-simple-example","text":"from repository_orm import Entity , load_repository class Author ( Entity ): first_name : str last_name : str country : str repo = load_repository ([ Author ]) author = Author ( first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( 0 ) assert brandon == author # Search entities brandon = repo . search ({ \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ()) == 0 # noqa","title":"A Simple Example"},{"location":"#repository-pattern-theory","text":"The repository pattern is an abstraction over persistent storage, allowing you to decouple the model layer from the data layer. It hides the boring details of data access by pretending that all of our data is in memory. It has the following advantages: Give a simple interface, which you control, between persistent storage and our domain model. It's easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because the model is fully decoupled from the infrastructure. Writing the domain model before thinking about persistence helps focus on the problem at hand. If we need to change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later. Our database schema is simple because we have complete control over how we map our object to tables. Speeds up and makes more clean the business logic tests. It's easy to implement. But the following disadvantages: An ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postres if you ever need to. Maintaining ORM mappings by hand requires extra work and extra code. An extra layer of abstraction is introduced, and although we may hope it will reduce complexity overall, it does add complexity locally. Furthermore it adds the WTF factor for Python programmers who've never seen this pattern before. repository-orm aims to mitigate the last ones by: Supplying classes that already have the common operations for different storage solutions. Supplying test classes and fixtures so extending the provided repositories is easy.","title":"Repository pattern theory"},{"location":"#usage","text":"The different repositories share the next operations: add Add an Entity object to the repository, if it already exist, it updates the stored attributes. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Get all the entities of a type or types from the repository. If no argument is given, it will return all entities. search Get the entities whose attributes match a condition or regular expression. first Get the first entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. last Get the last entity of a type or types of the repository. If no argument is given, it will return the first of any type of entity. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() .","title":"Usage"},{"location":"#repositories","text":"To change the repository you only need to change the url passed to load_repository . We have the next repositories: FakeRepository : is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. TinyDBRepository : is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. PypikaRepository : is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases.","title":"Repositories"},{"location":"#references","text":"As most open sourced programs, repository-orm is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . TinyDB Used to interact with the NoSQL database in the TinyDBRepository Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to repository-orm , see Contributing to repository-orm .","title":"Contributing"},{"location":"contributing/","text":"So you've started using repository-orm and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_orm.version; print(repository_orm.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-orm or know it's not relevant to your question or feature request. Pull Requests \u00b6 repository-orm is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-orm.git cd repository-orm Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-orm, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-orm uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-orm !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_orm.version; print(repository_orm.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-orm or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"repository-orm is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-orm.git cd repository-orm Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-orm, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-orm uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-orm !","title":"Development facilities"},{"location":"fake_repository/","text":"The FakeRepository is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. It stores the persisted Entities in the entities object attribute in a dictionary where the keys are the Entity class and the values are list of that Entity objects. When you try to make changes to the repository, the actual entities dictionary is copied to the new_entities attribute. The changes are made on that new attribute and once you use the commit method, they get copied back to the entities attribute. Load it with: from repository_orm import load_repository repo = load_repository () Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to the new_entities attribute. delete Deletes the Entity object from the new_entities attribute. get Obtain an Entity from the entities attribute by it's ID. commit Persist the changes of new_entities into entities , clearing up new_entities afterwards. all Obtain all the entities of type Entity from the entities attribute. search Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. apply_migrations Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing. Simulating errors \u00b6 ConnectionError \u00b6 To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"FakeRepository"},{"location":"fake_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to the new_entities attribute. delete Deletes the Entity object from the new_entities attribute. get Obtain an Entity from the entities attribute by it's ID. commit Persist the changes of new_entities into entities , clearing up new_entities afterwards. all Obtain all the entities of type Entity from the entities attribute. search Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. apply_migrations Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing.","title":"Features"},{"location":"fake_repository/#simulating-errors","text":"","title":"Simulating errors"},{"location":"fake_repository/#connectionerror","text":"To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"ConnectionError"},{"location":"models/","text":"When modeling the application logic through Domain Driven Design , you usually need the following object types: Value object : Any domain object that is uniquely identified by the data it holds, so it has no conceptual identity. They should be treated as immutable. We can still have complex behaviour in value objects. In fact, it's common to support operations, for example, mathematical operators. Entity : An object that is not defined by it's attributes, but rather by a thread of continuity and it's identity. Unlike values, they have identity equality . We can change their values, and they are still recognizably the same thing. Entities \u00b6 We've created the Entity class based on the pydantic's BaseModel to enforce that they have the id_ attribute of type int or str , used for comparison and hashing of entities. They also have a private _model_name attribute with the name of the model. If you use integer IDs (which is the default), you don't need to define the id_ at object creation. When you add the entity to the repository, it will populate it. from repository_orm import Entity , load_repository class Author ( Entity ): first_name : str repo = load_repository ([ Author ]) author = Author ( first_name = \"Brandon\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( 0 ) assert brandon == author # noqa This won't work with str ids!","title":"Models"},{"location":"models/#entities","text":"We've created the Entity class based on the pydantic's BaseModel to enforce that they have the id_ attribute of type int or str , used for comparison and hashing of entities. They also have a private _model_name attribute with the name of the model. If you use integer IDs (which is the default), you don't need to define the id_ at object creation. When you add the entity to the repository, it will populate it. from repository_orm import Entity , load_repository class Author ( Entity ): first_name : str repo = load_repository ([ Author ]) author = Author ( first_name = \"Brandon\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( 0 ) assert brandon == author # noqa This won't work with str ids!","title":"Entities"},{"location":"new_repo/","text":"First make sure you've read the contributing guidelines . All repository types are run against the same tests . Using the awesome library pytest-cases , we were able to separate the test cases from the test functions. The result is not simple to understand, but bear with me, as once you understand it, you may love it. The test cases are in the cases directory below tests . There are two files: entities.py : Where we define the different Entity objects to test through the methods of the EntityCases class. repositories.py : Where we define the different Repository objects to test through the methods of the RepositoryCases class. The Entity cases, return a factory defined with Factoryboy together with the Entity model, to create arbitrary objects with real values generated through Faker . The Repository cases are a little more complex, each of them returns a tuple with the following objects: db : A storage connection object to run direct queries in the tests. empty_repo : A repository instance without the schema applied. repo : A repository instance with the schema applied. repo_tester : A class to particularize the testing interface to each repository. Each repository needs different assertions to ensure that a functionality works as expected, this fact makes it really difficult to parametrize the tests. The solution I've found is to write the tests Making generic tests for The Entities to test are defined in the The interface definition of all repositories is done at the AbstractRepository class.","title":"Create new repository"},{"location":"pypika_repository/","text":"The PypikaRepository is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases. It stores the persisted Entities into a SQLite database tables ( Mysql support will come in the future ). It uses the Pypika query builder to generate the raw SQL statements and then sends them to the database through an sqlite3 connection. If you're wondering why we don't want to use SQLAlchemy or raw sql statements, check this article. Load it with: from repository_orm import load_repository repo = load_repository ( 'sqlite://path/to/database.db' ) Database schema \u00b6 The repository assumes there is a specific schema, where the table names are the same as the Entity clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example. Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to its table by translating its attributes to the columns. If it already exists, use the upsert statement to update it's attributes in the table. delete Deletes the Entity object from its table by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory. Internal workings \u00b6 This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query. References \u00b6 Pypika documentation Yoyo documentation","title":"PypikaRepository"},{"location":"pypika_repository/#database-schema","text":"The repository assumes there is a specific schema, where the table names are the same as the Entity clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example.","title":"Database schema"},{"location":"pypika_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to its table by translating its attributes to the columns. If it already exists, use the upsert statement to update it's attributes in the table. delete Deletes the Entity object from its table by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory.","title":"Features"},{"location":"pypika_repository/#internal-workings","text":"This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query.","title":"Internal workings"},{"location":"pypika_repository/#references","text":"Pypika documentation Yoyo documentation","title":"References"},{"location":"reference/","text":"repository_orm special \u00b6 Library to ease the implementation of the repository pattern in Python projects. adapters special \u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ abstract \u00b6 Define the interface of the repositories. Repository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , models = None , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' models Optional[List[Type[~Entity]]] List of stored entity models. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. models: List of stored entity models. \"\"\" self . database_url = database_url if models is None : models = [] self . models = models add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if isinstance ( entity . id_ , int ) and entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError first ( self , models ) \u00b6 Get the smallest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , models : OptionalModelOrModels [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: models: Type of entity object to obtain. Returns: entity: Smallest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( models )) except ValueError as error : models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" raise NotImplementedError last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( models )) except ValueError as error : # no cover: it's tested by it's subclasses models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , models = None , database_url = '' ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( models = models ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) self . entities : FakeRepositoryDB [ Entity ] = {} self . new_entities : FakeRepositoryDB [ Entity ] = {} add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/fake.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): entities += sorted ( entity for entity_id , entity in self . entities [ model ] . items () ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for model , entities in self . new_entities . items (): self . entities [ model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/fake.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): matching_entities . append ( self . entities [ model ][ id_ ]) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : models = self . _build_models ( models ) try : # Empty repo but entities staged to be commited. return max ( self . _staged_entities ( models )) except KeyError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : models = self . _build_models ( models ) last_staged_entity : Entity = max ( self . _staged_entities ( models )) except KeyError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ]) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" models = self . _build_models ( models ) all_entities : List [ Entity ] = self . all ( models ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( str ( value ), use_regexp = True , strict_checking = False ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" , path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query ) all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/pypika.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) entities += self . _build_entities ( model , query ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/pypika.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == id_ ) matching_entities += self . _build_entities ( model , query ) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) with suppress ( OperationalError ): entities += self . _build_entities ( model , query ) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities tinydb \u00b6 Define the TinyDB Repository. TinyDBRepository \u00b6 Implement the repository pattern using the TinyDB. add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity ) all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/tinydb.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) if models == self . models : entities_data = self . db_ . all () else : query = self . _build_model_query ( models ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity ) get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/tinydb.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" models = self . _build_models ( models ) model_query = self . _build_model_query ( models ) matching_entities_data = self . db_ . search (( Query () . id_ == id_ ) & ( model_query )) if len ( matching_entities_data ) == 1 : return self . _build_entity ( matching_entities_data [ 0 ], models ) elif len ( matching_entities_data ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/tinydb.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : try : # Empty repo but entities staged to be commited. return max ( self . staged [ \"add\" ]) except ValueError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : last_staged_entity = max ( self . staged [ \"add\" ]) except ValueError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ]) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) query_parts = [ self . _build_model_query ( models )] for key , value in fields . items (): if isinstance ( value , str ): query_parts . append ( Query ()[ key ] . search ( value )) else : query_parts . append ( Query ()[ key ] == value ) query = self . _build_query ( query_parts ) # Build entities entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities config \u00b6 Define the configuration of the main program. exceptions \u00b6 Store the repository-orm exceptions. AutoIncrementError \u00b6 Raised when the id_ auto increment repository feature fails. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails. TooManyEntitiesError \u00b6 Raised when more entities than expected where found. model \u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ > other . id_ # type: ignore __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __init__ ( self , ** data ) special \u00b6 Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__ __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ < other . id_ # type: ignore services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. load_repository ( models = None , database_url = None ) \u00b6 Load the Repository object that matches the database_url protocol. Parameters: Name Type Description Default database_url Optional[str] Url to connect to the storage backend. None Returns: Type Description Union[repository_orm.adapters.fake.FakeRepository, repository_orm.adapters.pypika.PypikaRepository, repository_orm.adapters.tinydb.TinyDBRepository] Repository that understands the url protocol. Source code in repository_orm/services.py def load_repository ( models : Optional [ Models [ Entity ]] = None , database_url : Optional [ str ] = None ) -> Repository : \"\"\"Load the Repository object that matches the database_url protocol. Args: database_url: Url to connect to the storage backend. Returns: Repository that understands the url protocol. \"\"\" if database_url is None or \"fake://\" in database_url : repo : Repository = FakeRepository ( models , \"\" ) elif \"sqlite://\" in database_url : repo = PypikaRepository ( models , database_url ) elif \"tinydb://\" in database_url : repo = TinyDBRepository ( models , database_url ) return repo version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in repository_orm/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_orm version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#repository_orm","text":"Library to ease the implementation of the repository pattern in Python projects.","title":"repository_orm"},{"location":"reference/#repository_orm.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"adapters"},{"location":"reference/#repository_orm.adapters.abstract","text":"Define the interface of the repositories.","title":"abstract"},{"location":"reference/#repository_orm.adapters.abstract.Repository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"Repository"},{"location":"reference/#repository_orm.adapters.abstract.Repository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' models Optional[List[Type[~Entity]]] List of stored entity models. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. models: List of stored entity models. \"\"\" self . database_url = database_url if models is None : models = [] self . models = models","title":"__init__()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if isinstance ( entity . id_ , int ) and entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError","title":"add()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.first","text":"Get the smallest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , models : OptionalModelOrModels [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: models: Type of entity object to obtain. Returns: entity: Smallest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( models )) except ValueError as error : models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover","title":"first()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( models )) except ValueError as error : # no cover: it's tested by it's subclasses models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover","title":"last()"},{"location":"reference/#repository_orm.adapters.abstract.Repository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference/#repository_orm.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( models = models ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) self . entities : FakeRepositoryDB [ Entity ] = {} self . new_entities : FakeRepositoryDB [ Entity ] = {}","title":"__init__()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/fake.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): entities += sorted ( entity for entity_id , entity in self . entities [ model ] . items () ) return entities","title":"all()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for model , entities in self . new_entities . items (): self . entities [ model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/fake.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): matching_entities . append ( self . entities [ model ][ id_ ]) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : models = self . _build_models ( models ) try : # Empty repo but entities staged to be commited. return max ( self . _staged_entities ( models )) except KeyError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : models = self . _build_models ( models ) last_staged_entity : Entity = max ( self . _staged_entities ( models )) except KeyError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ])","title":"last()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" models = self . _build_models ( models ) all_entities : List [ Entity ] = self . all ( models ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( str ( value ), use_regexp = True , strict_checking = False ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" , path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities","title":"search()"},{"location":"reference/#repository_orm.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query )","title":"add()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/pypika.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) entities += self . _build_entities ( model , query ) return entities","title":"all()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/pypika.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == id_ ) matching_entities += self . _build_entities ( model , query ) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) with suppress ( OperationalError ): entities += self . _build_entities ( model , query ) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities","title":"search()"},{"location":"reference/#repository_orm.adapters.tinydb","text":"Define the TinyDB Repository.","title":"tinydb"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository","text":"Implement the repository pattern using the TinyDB.","title":"TinyDBRepository"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity )","title":"add()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/tinydb.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) if models == self . models : entities_data = self . db_ . all () else : query = self . _build_model_query ( models ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) return entities","title":"all()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear ()","title":"commit()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity )","title":"delete()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/tinydb.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" models = self . _build_models ( models ) model_query = self . _build_model_query ( models ) matching_entities_data = self . db_ . search (( Query () . id_ == id_ ) & ( model_query )) if len ( matching_entities_data ) == 1 : return self . _build_entity ( matching_entities_data [ 0 ], models ) elif len ( matching_entities_data ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/tinydb.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : try : # Empty repo but entities staged to be commited. return max ( self . staged [ \"add\" ]) except ValueError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : last_staged_entity = max ( self . staged [ \"add\" ]) except ValueError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ])","title":"last()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) query_parts = [ self . _build_model_query ( models )] for key , value in fields . items (): if isinstance ( value , str ): query_parts . append ( Query ()[ key ] . search ( value )) else : query_parts . append ( Query ()[ key ] == value ) query = self . _build_query ( query_parts ) # Build entities entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities","title":"search()"},{"location":"reference/#repository_orm.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#repository_orm.exceptions","text":"Store the repository-orm exceptions.","title":"exceptions"},{"location":"reference/#repository_orm.exceptions.AutoIncrementError","text":"Raised when the id_ auto increment repository feature fails.","title":"AutoIncrementError"},{"location":"reference/#repository_orm.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference/#repository_orm.exceptions.TooManyEntitiesError","text":"Raised when more entities than expected where found.","title":"TooManyEntitiesError"},{"location":"reference/#repository_orm.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference/#repository_orm.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository.","title":"Entity"},{"location":"reference/#repository_orm.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ > other . id_ # type: ignore","title":"__gt__()"},{"location":"reference/#repository_orm.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference/#repository_orm.model.Entity.__init__","text":"Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__","title":"__init__()"},{"location":"reference/#repository_orm.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ < other . id_ # type: ignore","title":"__lt__()"},{"location":"reference/#repository_orm.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#repository_orm.services.load_repository","text":"Load the Repository object that matches the database_url protocol. Parameters: Name Type Description Default database_url Optional[str] Url to connect to the storage backend. None Returns: Type Description Union[repository_orm.adapters.fake.FakeRepository, repository_orm.adapters.pypika.PypikaRepository, repository_orm.adapters.tinydb.TinyDBRepository] Repository that understands the url protocol. Source code in repository_orm/services.py def load_repository ( models : Optional [ Models [ Entity ]] = None , database_url : Optional [ str ] = None ) -> Repository : \"\"\"Load the Repository object that matches the database_url protocol. Args: database_url: Url to connect to the storage backend. Returns: Repository that understands the url protocol. \"\"\" if database_url is None or \"fake://\" in database_url : repo : Repository = FakeRepository ( models , \"\" ) elif \"sqlite://\" in database_url : repo = PypikaRepository ( models , database_url ) elif \"tinydb://\" in database_url : repo = TinyDBRepository ( models , database_url ) return repo","title":"load_repository()"},{"location":"reference/#repository_orm.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#repository_orm.version.version_info","text":"Display the version of the program, python and the platform. Source code in repository_orm/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_orm version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"reference_adapters/","text":"repository_orm.adapters special \u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ abstract \u00b6 Define the interface of the repositories. Repository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , models = None , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' models Optional[List[Type[~Entity]]] List of stored entity models. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. models: List of stored entity models. \"\"\" self . database_url = database_url if models is None : models = [] self . models = models add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if isinstance ( entity . id_ , int ) and entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError first ( self , models ) \u00b6 Get the smallest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , models : OptionalModelOrModels [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: models: Type of entity object to obtain. Returns: entity: Smallest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( models )) except ValueError as error : models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" raise NotImplementedError last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( models )) except ValueError as error : # no cover: it's tested by it's subclasses models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , models = None , database_url = '' ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( models = models ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) self . entities : FakeRepositoryDB [ Entity ] = {} self . new_entities : FakeRepositoryDB [ Entity ] = {} add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/fake.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): entities += sorted ( entity for entity_id , entity in self . entities [ model ] . items () ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for model , entities in self . new_entities . items (): self . entities [ model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/fake.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): matching_entities . append ( self . entities [ model ][ id_ ]) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : models = self . _build_models ( models ) try : # Empty repo but entities staged to be commited. return max ( self . _staged_entities ( models )) except KeyError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : models = self . _build_models ( models ) last_staged_entity : Entity = max ( self . _staged_entities ( models )) except KeyError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ]) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" models = self . _build_models ( models ) all_entities : List [ Entity ] = self . all ( models ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( str ( value ), use_regexp = True , strict_checking = False ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" , path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query ) all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/pypika.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) entities += self . _build_entities ( model , query ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/pypika.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == id_ ) matching_entities += self . _build_entities ( model , query ) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) with suppress ( OperationalError ): entities += self . _build_entities ( model , query ) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities tinydb \u00b6 Define the TinyDB Repository. TinyDBRepository \u00b6 Implement the repository pattern using the TinyDB. add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity ) all ( self , models = None ) \u00b6 Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/tinydb.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) if models == self . models : entities_data = self . db_ . all () else : query = self . _build_model_query ( models ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity ) get ( self , id_ , models = None ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/tinydb.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" models = self . _build_models ( models ) model_query = self . _build_model_query ( models ) matching_entities_data = self . db_ . search (( Query () . id_ == id_ ) & ( model_query )) if len ( matching_entities_data ) == 1 : return self . _build_entity ( matching_entities_data [ 0 ], models ) elif len ( matching_entities_data ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" ) last ( self , models = None ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/tinydb.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : try : # Empty repo but entities staged to be commited. return max ( self . staged [ \"add\" ]) except ValueError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : last_staged_entity = max ( self . staged [ \"add\" ]) except ValueError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ]) search ( self , fields , models = None ) \u00b6 Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) query_parts = [ self . _build_model_query ( models )] for key , value in fields . items (): if isinstance ( value , str ): query_parts . append ( Query ()[ key ] . search ( value )) else : query_parts . append ( Query ()[ key ] == value ) query = self . _build_query ( query_parts ) # Build entities entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities","title":"Repository Implementations"},{"location":"reference_adapters/#repository_orm.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"adapters"},{"location":"reference_adapters/#repository_orm.adapters.abstract","text":"Define the interface of the repositories.","title":"abstract"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"Repository"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' models Optional[List[Type[~Entity]]] List of stored entity models. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. models: List of stored entity models. \"\"\" self . database_url = database_url if models is None : models = [] self . models = models","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if isinstance ( entity . id_ , int ) and entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.first","text":"Get the smallest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , models : OptionalModelOrModels [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: models: Type of entity object to obtain. Returns: entity: Smallest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( models )) except ValueError as error : models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover","title":"first()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( models )) except ValueError as error : # no cover: it's tested by it's subclasses models = self . _build_models ( models ) # pragma: nocover raise self . _model_not_found ( models ) from error # pragma: nocover","title":"last()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.Repository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , models : OptionalModels [ Entity ] = None , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( models = models ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) self . entities : FakeRepositoryDB [ Entity ] = {} self . new_entities : FakeRepositoryDB [ Entity ] = {}","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/fake.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): entities += sorted ( entity for entity_id , entity in self . entities [ model ] . items () ) return entities","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for model , entities in self . new_entities . items (): self . entities [ model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/fake.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : with suppress ( KeyError ): matching_entities . append ( self . entities [ model ][ id_ ]) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : models = self . _build_models ( models ) try : # Empty repo but entities staged to be commited. return max ( self . _staged_entities ( models )) except KeyError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : models = self . _build_models ( models ) last_staged_entity : Entity = max ( self . _staged_entities ( models )) except KeyError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ])","title":"last()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" models = self . _build_models ( models ) all_entities : List [ Entity ] = self . all ( models ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( str ( value ), use_regexp = True , strict_checking = False ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" , path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query )","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/pypika.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) entities += self . _build_entities ( model , query ) return entities","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/pypika.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" matching_entities = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == id_ ) matching_entities += self . _build_entities ( model , query ) if len ( matching_entities ) == 1 : return matching_entities [ 0 ] elif len ( matching_entities ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) for model in models : table = self . _table_model ( model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) with suppress ( OperationalError ): entities += self . _build_entities ( model , query ) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb","text":"Define the TinyDB Repository.","title":"tinydb"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository","text":"Implement the repository pattern using the TinyDB.","title":"TinyDBRepository"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if isinstance ( entity . id_ , int ) and entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity )","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.all","text":"Get all the entities from the repository whose class is included in models. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Source code in repository_orm/adapters/tinydb.py def all ( self , models : OptionalModelOrModels [ Entity ] = None ) -> List [ Entity ]: \"\"\"Get all the entities from the repository whose class is included in models. Args: models: Entity class or classes to obtain. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) if models == self . models : entities_data = self . db_ . all () else : query = self . _build_model_query ( models ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) return entities","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear ()","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( entity . id_ , type ( entity )) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity )","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None id_ Union[int, str] ID of the entity to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. TooManyEntitiesError If more than one entity was found. Source code in repository_orm/adapters/tinydb.py def get ( self , id_ : EntityID , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: models: Entity class or classes to obtain. id_: ID of the entity to obtain. Returns: entity: Entity object that matches the id_ Raises: EntityNotFoundError: If the entity is not found. TooManyEntitiesError: If more than one entity was found. \"\"\" models = self . _build_models ( models ) model_query = self . _build_model_query ( models ) matching_entities_data = self . db_ . search (( Query () . id_ == id_ ) & ( model_query )) if len ( matching_entities_data ) == 1 : return self . _build_entity ( matching_entities_data [ 0 ], models ) elif len ( matching_entities_data ) == 0 : raise self . _model_not_found ( models , f \" with id { id_ } \" ) else : raise TooManyEntitiesError ( f \"More than one entity was found with the id { id_ } \" )","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/tinydb.py def last ( self , models : OptionalModelOrModels [ Entity ] = None ) -> Entity : \"\"\"Get the biggest entity from the repository. Args: models: Entity class or classes to obtain. Returns: entity: Biggest Entity object of type models. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : last_index_entity : Entity = super () . last ( models ) except EntityNotFoundError as empty_repo : try : # Empty repo but entities staged to be commited. return max ( self . staged [ \"add\" ]) except ValueError as no_staged_entities : # Empty repo and no entities staged. raise empty_repo from no_staged_entities try : last_staged_entity = max ( self . staged [ \"add\" ]) except ValueError : # Full repo and no staged entities. return last_index_entity # Full repo and staged entities. return max ([ last_index_entity , last_staged_entity ])","title":"last()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.search","text":"Get the entities whose attributes match one or several conditions. Parameters: Name Type Description Default models Union[Type[~Entity], List[Type[~Entity]]] Entity class or classes to obtain. None fields Dict[str, Union[int, str]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , fields : Dict [ str , EntityID ], models : OptionalModelOrModels [ Entity ] = None , ) -> List [ Entity ]: \"\"\"Get the entities whose attributes match one or several conditions. Args: models: Entity class or classes to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities : List [ Entity ] = [] models = self . _build_models ( models ) query_parts = [ self . _build_model_query ( models )] for key , value in fields . items (): if isinstance ( value , str ): query_parts . append ( Query ()[ key ] . search ( value )) else : query_parts . append ( Query ()[ key ] == value ) query = self . _build_query ( query_parts ) # Build entities entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data )) if len ( entities ) == 0 : raise self . _model_not_found ( models , f \" that match the search filter { fields } \" ) return entities","title":"search()"},{"location":"reference_exceptions/","text":"repository_orm.exceptions \u00b6 Store the repository-orm exceptions. AutoIncrementError \u00b6 Raised when the id_ auto increment repository feature fails. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails. TooManyEntitiesError \u00b6 Raised when more entities than expected where found.","title":"Exceptions"},{"location":"reference_exceptions/#repository_orm.exceptions","text":"Store the repository-orm exceptions.","title":"exceptions"},{"location":"reference_exceptions/#repository_orm.exceptions.AutoIncrementError","text":"Raised when the id_ auto increment repository feature fails.","title":"AutoIncrementError"},{"location":"reference_exceptions/#repository_orm.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference_exceptions/#repository_orm.exceptions.TooManyEntitiesError","text":"Raised when more entities than expected where found.","title":"TooManyEntitiesError"},{"location":"reference_models/","text":"repository_orm.model \u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ > other . id_ # type: ignore __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __init__ ( self , ** data ) special \u00b6 Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__ __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ < other . id_ # type: ignore","title":"Models"},{"location":"reference_models/#repository_orm.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference_models/#repository_orm.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository.","title":"Entity"},{"location":"reference_models/#repository_orm.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ > other . id_ # type: ignore","title":"__gt__()"},{"location":"reference_models/#repository_orm.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference_models/#repository_orm.model.Entity.__init__","text":"Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__","title":"__init__()"},{"location":"reference_models/#repository_orm.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) # ignore: we've checked that both elements are of the same type return self . id_ < other . id_ # type: ignore","title":"__lt__()"},{"location":"testing/","text":"Testing your code is a hated but good practice. Repository ORM tries to make your testing experience less cumbersome. You can use different strategies depending on the level of testing. For unit and integration tests the FakeRepository may be your best option, for end-to-end ones, I'd use TinyDBRepository . Unit and integration tests \u00b6 Unit tests are meant to test individual units of code, for example, a function or a method of a class. You'll probably use them to test your models or services . import pytest from repository_orm import Entity , FakeRepository , Repository @pytest . fixture () def repo () -> FakeRepository : return FakeRepository () class Author ( Entity ): first_name : str def create_greeting ( repo : Repository , author_id : int ) -> str : author = repo . get ( author_id , Author ) return f \"Hi { author . first_name } !\" def test_greetings ( repo : FakeRepository ) -> None : author = Author ( id_ = 20 , first_name = \"Brandon\" ) repo . add ( author ) repo . commit () result = create_greeting ( repo , 20 ) assert result == \"Hi Brandon!\" # noqa End-to-end tests \u00b6 End-to-end tests evaluate the whole functionality of the program from the eyes of the user. For example, testing a command line or the API endpoint. Usually the program loads the repository from storage at start time, which means that the FakeRepository can't be used. We're going to create a click command line program called greet that once it's called, it will return the first author in the repository. It's a little bit more complex but bare with me. import click import pytest from click.testing import CliRunner from py._path.local import LocalPath from repository_orm import Entity , Repository , TinyDBRepository , load_repository # Model class Author ( Entity ): first_name : str # Fixtures @pytest . fixture ( name = \"db_tinydb\" ) def db_tinydb_ ( tmpdir : LocalPath ) -> str : tinydb_file_path = str ( tmpdir . join ( \"tinydb.db\" )) return f \"tinydb:/// { tinydb_file_path } \" @pytest . fixture () def repo ( db_tinydb : str ) -> TinyDBRepository : return TinyDBRepository ([ Author ], db_tinydb ) # Service def create_greeting ( repo : Repository ) -> str : first_author = repo . all ( Author )[ 0 ] return f \"Hi { first_author . first_name } , you're the first author!\" # Entrypoint @click . command () @click . argument ( \"database_url\" ) def greet ( database_url : str ) -> None : repo = load_repository ([ Author ], database_url ) print ( create_greeting ( repo )) # Test def test_greetings ( repo : TinyDBRepository , db_tinydb : str ) -> None : author = Author ( id_ = 20 , first_name = \"Brandon\" ) repo . add ( author ) repo . commit () runner = CliRunner () result = runner . invoke ( greet , [ db_tinydb ]) assert result . exit_code == 0 assert result . output == \"Hi Brandon, you're the first author! \\n \" # noqa First we define the fixtures, we start with db_tinydb that uses the pytest's tmpdir fixture to create a random temporal directory and then sets the database url. The repo fixture uses that database url to create a TinyDBRepository instance. The model Author and service create_greeting are similar to the previous section. The entrypoint is where we define the command line interface, in this case the command is going to be called greet and it's going to accept an argument called database_url , it will initialize the repository and use the create_greeting to show the message to the user through the terminal. To test this code, we first need to add an Author, so the function can look for it. We do it in the first three lines of test_greetings . Then we initialize the runner which simulates a command line call, and we make sure that the program exited well, and gave the output we expected.","title":"Testing"},{"location":"testing/#unit-and-integration-tests","text":"Unit tests are meant to test individual units of code, for example, a function or a method of a class. You'll probably use them to test your models or services . import pytest from repository_orm import Entity , FakeRepository , Repository @pytest . fixture () def repo () -> FakeRepository : return FakeRepository () class Author ( Entity ): first_name : str def create_greeting ( repo : Repository , author_id : int ) -> str : author = repo . get ( author_id , Author ) return f \"Hi { author . first_name } !\" def test_greetings ( repo : FakeRepository ) -> None : author = Author ( id_ = 20 , first_name = \"Brandon\" ) repo . add ( author ) repo . commit () result = create_greeting ( repo , 20 ) assert result == \"Hi Brandon!\" # noqa","title":"Unit and integration tests"},{"location":"testing/#end-to-end-tests","text":"End-to-end tests evaluate the whole functionality of the program from the eyes of the user. For example, testing a command line or the API endpoint. Usually the program loads the repository from storage at start time, which means that the FakeRepository can't be used. We're going to create a click command line program called greet that once it's called, it will return the first author in the repository. It's a little bit more complex but bare with me. import click import pytest from click.testing import CliRunner from py._path.local import LocalPath from repository_orm import Entity , Repository , TinyDBRepository , load_repository # Model class Author ( Entity ): first_name : str # Fixtures @pytest . fixture ( name = \"db_tinydb\" ) def db_tinydb_ ( tmpdir : LocalPath ) -> str : tinydb_file_path = str ( tmpdir . join ( \"tinydb.db\" )) return f \"tinydb:/// { tinydb_file_path } \" @pytest . fixture () def repo ( db_tinydb : str ) -> TinyDBRepository : return TinyDBRepository ([ Author ], db_tinydb ) # Service def create_greeting ( repo : Repository ) -> str : first_author = repo . all ( Author )[ 0 ] return f \"Hi { first_author . first_name } , you're the first author!\" # Entrypoint @click . command () @click . argument ( \"database_url\" ) def greet ( database_url : str ) -> None : repo = load_repository ([ Author ], database_url ) print ( create_greeting ( repo )) # Test def test_greetings ( repo : TinyDBRepository , db_tinydb : str ) -> None : author = Author ( id_ = 20 , first_name = \"Brandon\" ) repo . add ( author ) repo . commit () runner = CliRunner () result = runner . invoke ( greet , [ db_tinydb ]) assert result . exit_code == 0 assert result . output == \"Hi Brandon, you're the first author! \\n \" # noqa First we define the fixtures, we start with db_tinydb that uses the pytest's tmpdir fixture to create a random temporal directory and then sets the database url. The repo fixture uses that database url to create a TinyDBRepository instance. The model Author and service create_greeting are similar to the previous section. The entrypoint is where we define the command line interface, in this case the command is going to be called greet and it's going to accept an argument called database_url , it will initialize the repository and use the create_greeting to show the message to the user through the terminal. To test this code, we first need to add an Author, so the function can look for it. We do it in the first three lines of test_greetings . Then we initialize the runner which simulates a command line call, and we make sure that the program exited well, and gave the output we expected.","title":"End-to-end tests"},{"location":"tinydb_repository/","text":"The TinyDBRepository is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. It stores the persisted Entities into a json file. Load it with: from repository_orm import load_repository repo = load_repository ( 'tinydb://path/to/database.db' ) Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to the default table by translating its attributes to a valid json row. If it already exists, it uses the upsert statement to update it's attributes in the table. delete Deletes the Entity object from the collection by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations We don't yet support migrations on the schema , so the models should be flexible enough to absorb the changes, or you can code your migrations in your program, or even better, help us solve #27 . Internal workings \u00b6 This section is meant for the people that you to expand the functionality of the TinyDBRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format tinydb:///path_to_database_file , an TinyDB object is created in the db_ attribute, the path to the database is saved in database_file and a empty dictionary of staged changes is created in staged . Saving entities \u00b6 All entities are saved in the same default table _default , to avoid id_ collision, before storing the objects, an model_type_ attribute is appended with the lowercase name of the entity class. When retrieving objects with get and all , the attribute is deleted. Committing \u00b6 TinyDB doesn't have the concept of transactions, the tinyrecord plugin does, but you need to run everything in the same context manager, which doesn't suit our case. So whenever we add or remove an entity from the repository, they are stored in the staged attribute, and once commit is called, they are persisted into the database. References \u00b6 TinyDB documentation","title":"TinyDBRepository"},{"location":"tinydb_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to the default table by translating its attributes to a valid json row. If it already exists, it uses the upsert statement to update it's attributes in the table. delete Deletes the Entity object from the collection by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations We don't yet support migrations on the schema , so the models should be flexible enough to absorb the changes, or you can code your migrations in your program, or even better, help us solve #27 .","title":"Features"},{"location":"tinydb_repository/#internal-workings","text":"This section is meant for the people that you to expand the functionality of the TinyDBRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format tinydb:///path_to_database_file , an TinyDB object is created in the db_ attribute, the path to the database is saved in database_file and a empty dictionary of staged changes is created in staged .","title":"Internal workings"},{"location":"tinydb_repository/#saving-entities","text":"All entities are saved in the same default table _default , to avoid id_ collision, before storing the objects, an model_type_ attribute is appended with the lowercase name of the entity class. When retrieving objects with get and all , the attribute is deleted.","title":"Saving entities"},{"location":"tinydb_repository/#committing","text":"TinyDB doesn't have the concept of transactions, the tinyrecord plugin does, but you need to run everything in the same context manager, which doesn't suit our case. So whenever we add or remove an entity from the repository, they are stored in the staged attribute, and once commit is called, they are persisted into the database.","title":"Committing"},{"location":"tinydb_repository/#references","text":"TinyDB documentation","title":"References"},{"location":"adr/001-entity_id_definition/","text":"Status \u00b6 Superseeded It has been partially superseeded by 002 String ids are again supported. Context \u00b6 Right now the Entity class has a mandatory id_ attribute of types str or int . That prevents the user to create entities a model level as they are not aware of the existent entities in the repository. Proposals \u00b6 We can: Assume that the model functions that create the new entities receive the new entity id as an argument. Change the definition of the id_ attribute so that it can be set by the repository at the moment of adding it to the repository. I've started using the first in pydo and found it cumbersome. The first approximation for the second can be to assume that the id_ is an integer, by default is set to a negative value, marking it as invalid, and when the repository sees it, gets the last id and increments it in a unit. This can't be easily done if the id_ is a str . So I'm temporarily dropping support for this types of IDs. If anyone needs them, we can create a workaround like converting them to an ascii integer and increasing it by one. If we want more complex objects to be used as ids, we may think of letting the user specify a callable to increase the ids. Decision \u00b6 We're setting a default id_ value of -1 on Entities, the repository will react to these ids, getting the last valid ID and increasing it by one. Consequences \u00b6 As a side effect, we're temporarily dropping support for str id_ attributes.","title":"Status"},{"location":"adr/001-entity_id_definition/#status","text":"Superseeded It has been partially superseeded by 002 String ids are again supported.","title":"Status"},{"location":"adr/001-entity_id_definition/#context","text":"Right now the Entity class has a mandatory id_ attribute of types str or int . That prevents the user to create entities a model level as they are not aware of the existent entities in the repository.","title":"Context"},{"location":"adr/001-entity_id_definition/#proposals","text":"We can: Assume that the model functions that create the new entities receive the new entity id as an argument. Change the definition of the id_ attribute so that it can be set by the repository at the moment of adding it to the repository. I've started using the first in pydo and found it cumbersome. The first approximation for the second can be to assume that the id_ is an integer, by default is set to a negative value, marking it as invalid, and when the repository sees it, gets the last id and increments it in a unit. This can't be easily done if the id_ is a str . So I'm temporarily dropping support for this types of IDs. If anyone needs them, we can create a workaround like converting them to an ascii integer and increasing it by one. If we want more complex objects to be used as ids, we may think of letting the user specify a callable to increase the ids.","title":"Proposals"},{"location":"adr/001-entity_id_definition/#decision","text":"We're setting a default id_ value of -1 on Entities, the repository will react to these ids, getting the last valid ID and increasing it by one.","title":"Decision"},{"location":"adr/001-entity_id_definition/#consequences","text":"As a side effect, we're temporarily dropping support for str id_ attributes.","title":"Consequences"},{"location":"adr/002-support-string-ids/","text":"Status \u00b6 Accepted Context \u00b6 In version 0.3.0 we dropped support for string ids, and that was a bad decision, as there are already projects that use it. The reason of deprecation was because the new feature to auto increment the ID of the entities that hadn't set it, wasn't \"easy\" to implement for strings. Proposals \u00b6 Restore the support for string ids, but without the auto increment feature. If you're using string ids is probably because you have an id generator or you're getting them from outside sources. Decision \u00b6 Consequences \u00b6","title":"Status"},{"location":"adr/002-support-string-ids/#status","text":"Accepted","title":"Status"},{"location":"adr/002-support-string-ids/#context","text":"In version 0.3.0 we dropped support for string ids, and that was a bad decision, as there are already projects that use it. The reason of deprecation was because the new feature to auto increment the ID of the entities that hadn't set it, wasn't \"easy\" to implement for strings.","title":"Context"},{"location":"adr/002-support-string-ids/#proposals","text":"Restore the support for string ids, but without the auto increment feature. If you're using string ids is probably because you have an id generator or you're getting them from outside sources.","title":"Proposals"},{"location":"adr/002-support-string-ids/#decision","text":"","title":"Decision"},{"location":"adr/002-support-string-ids/#consequences","text":"","title":"Consequences"},{"location":"adr/003-make_entity_models_optional_arguments/","text":"Status \u00b6 Accepted Context \u00b6 Some applications need to do operations on all or a subset of entity types in the repository, for example for the get , search , all , first or last . Right now the entity_model is a mandatory argument for these methods, that means that the code calling the repository needs to be aware of all the entity models inside the repository and call the methods for each of them. Proposals \u00b6 To solve it, we should change the entity_model an argument to a more flexible type Union[Type[Entity], List[Type[Entity]], None] . That change carries some side effects: We need to add logic at repository level to process one, a subset or all the entity types. Some repositories (tinydb and pypika) used the entity_model to build the entity, if it's not specified, we need to build the logic that lets them build the entities from their data. The calls to the methods without specifying the entity_model can have a worse performance. Build the Entities from their data \u00b6 To build the entities from the data we need those methods to be able to link that data to a model type, we can either: Delegate that functionality to the application using the repository. Configure the repositories in a way that we can deduce the model from the data stored in itself. The first solution means that each application will need to implement and maintain that code, which will lead to more maintenance and duplicated code, but a simpler repository configuration. The second solution will mean that the code for the methods is more complex and/or the repository initialization needs more arguments. We already store the key information that tells which model does the data belong to. In the tinydb repo it's stored as an attribute _model_type , and in the pypika repo is stored as tables names. The fake repo doesn't have this problem. If we initialize the repository with a models optional argument, with a list of the entity models, we can create an internal models attribute that holds a dictionary with the key equal to the value stored in the repos, and the value the model type. If the user doesn't provide this argument at repo initialization, it will be supposed that it will give the entity_model on each of the repo methods that require it, otherwise an error will be shown. Performance loss \u00b6 The entity_model acted as a filter on the amount of data to perform the operations, if the user doesn't specify it, the repo needs to work with more data and therefore be slower. Maybe some of the methods like all , first , or last will work faster on some repositories based on how they or their libraries work, but the get and search will definitely go slower. In the case of get we can mitigate it with an optional callable argument that can run regexps on the id to select the subset of entity models that contain id's of that type. Decision \u00b6 Change the signatures of the get , search , all , first and last methods to accept one, many or no Entity subclasses. If none is given, it will assume that the repository was initialized with the models argument, where the user gives the repo the model of the data it holds. For the sake of cleanness, we're renaming entity_models for models in the function arguments. Consequences \u00b6 The change makes the library more usable while it retains the performance of the previous code base. Two breaking changes were introduced though: The argument entity_model is no longer the first one for the methods get and search , but the second. The argument database_url is no longer the first argument in the load_repository function, but the second, being the first the models .","title":"Status"},{"location":"adr/003-make_entity_models_optional_arguments/#status","text":"Accepted","title":"Status"},{"location":"adr/003-make_entity_models_optional_arguments/#context","text":"Some applications need to do operations on all or a subset of entity types in the repository, for example for the get , search , all , first or last . Right now the entity_model is a mandatory argument for these methods, that means that the code calling the repository needs to be aware of all the entity models inside the repository and call the methods for each of them.","title":"Context"},{"location":"adr/003-make_entity_models_optional_arguments/#proposals","text":"To solve it, we should change the entity_model an argument to a more flexible type Union[Type[Entity], List[Type[Entity]], None] . That change carries some side effects: We need to add logic at repository level to process one, a subset or all the entity types. Some repositories (tinydb and pypika) used the entity_model to build the entity, if it's not specified, we need to build the logic that lets them build the entities from their data. The calls to the methods without specifying the entity_model can have a worse performance.","title":"Proposals"},{"location":"adr/003-make_entity_models_optional_arguments/#build-the-entities-from-their-data","text":"To build the entities from the data we need those methods to be able to link that data to a model type, we can either: Delegate that functionality to the application using the repository. Configure the repositories in a way that we can deduce the model from the data stored in itself. The first solution means that each application will need to implement and maintain that code, which will lead to more maintenance and duplicated code, but a simpler repository configuration. The second solution will mean that the code for the methods is more complex and/or the repository initialization needs more arguments. We already store the key information that tells which model does the data belong to. In the tinydb repo it's stored as an attribute _model_type , and in the pypika repo is stored as tables names. The fake repo doesn't have this problem. If we initialize the repository with a models optional argument, with a list of the entity models, we can create an internal models attribute that holds a dictionary with the key equal to the value stored in the repos, and the value the model type. If the user doesn't provide this argument at repo initialization, it will be supposed that it will give the entity_model on each of the repo methods that require it, otherwise an error will be shown.","title":"Build the Entities from their data"},{"location":"adr/003-make_entity_models_optional_arguments/#performance-loss","text":"The entity_model acted as a filter on the amount of data to perform the operations, if the user doesn't specify it, the repo needs to work with more data and therefore be slower. Maybe some of the methods like all , first , or last will work faster on some repositories based on how they or their libraries work, but the get and search will definitely go slower. In the case of get we can mitigate it with an optional callable argument that can run regexps on the id to select the subset of entity models that contain id's of that type.","title":"Performance loss"},{"location":"adr/003-make_entity_models_optional_arguments/#decision","text":"Change the signatures of the get , search , all , first and last methods to accept one, many or no Entity subclasses. If none is given, it will assume that the repository was initialized with the models argument, where the user gives the repo the model of the data it holds. For the sake of cleanness, we're renaming entity_models for models in the function arguments.","title":"Decision"},{"location":"adr/003-make_entity_models_optional_arguments/#consequences","text":"The change makes the library more usable while it retains the performance of the previous code base. Two breaking changes were introduced though: The argument entity_model is no longer the first one for the methods get and search , but the second. The argument database_url is no longer the first argument in the load_repository function, but the second, being the first the models .","title":"Consequences"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: Entity ID definition] 002[002: Support String IDs] 003[003: Make entity_model optional arguments] click 001 \"https://lyz-code.github.io/repository-orm/adr/001-entity_id_definition/\" _blank click 002 \"https://lyz-code.github.io/repository-orm/adr/002-support_string_ids/\" _blank click 003 \"https://lyz-code.github.io/repository-orm/adr/003-make_entity_models_optional_arguments/\" _blank 001 -- Partially superseeded --> 002 001:::superseeded 002:::accepted 003:::accepted classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Architecture Decision Records"}]}