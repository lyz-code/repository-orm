{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Library to ease the implementation of the repository pattern in python projects. The repository pattern is an abstraction over persistent storage, allowing us to decouple our model layer from the data layer. It hides the boring details of data access by pretending that all of our data is in memory. It has the following advantages: We get a simple interface, which we control, between persistent storage and our domain model. It's easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because we've fully decoupled the model from infrastructure concerns. Writing the domain model before thinking about persistence helps us focus on the business problem at hand. If we need to change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later. Our database schema is simple because we have complete control over how we map our object to tables. Speeds up and makes more clean the business logic tests. It's easy to implement. But the following disadvantages: An ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postres if you ever need to. Maintaining ORM mappings by hand requires extra work and extra code. An extra layer of abstraction is introduced, and although we may hope it will reduce complexity overall, it does add complexity locally. Furthermore it adds the WTF factor for Python programmers who've never seen this pattern before. repository-orm aims to mitigate the last ones by: Supplying classes that already have the common operations for different storage solutions. Supplying test classes and fixtures so extending the provided repositories is easy. Installing \u00b6 pip install repository-orm A Simple Example \u00b6 from repository_orm import Entity , load_repository repo = load_repository () class Author ( Entity ): id_ : int first_name : str last_name : str country : str author = Author ( id_ = 0 , first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( Author , 0 ) assert brandon == author # Search entities brandon = repo . search ( Author , { \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ( Author )) == 0 # noqa Usage \u00b6 The different repositories share the following operations: add Add an Entity object to the repository, if it already exist, update the stored attributes. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Get all the entities of type Entity from the repository. search Get the entities whose attributes match a condition or regular expression. first Get the first entity in the repository. last Get the first entity in the repository. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() . Repositories \u00b6 To change the repository you only need to change the url passed to load_repository . We have the next repositories: FakeRepository : is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. TinyDBRepository : is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. PypikaRepository : is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases. References \u00b6 As most open sourced programs, repository-orm is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . TinyDB Used to interact with the NoSQL database in the TinyDBRepository Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to repository-orm , see Contributing to repository-orm .","title":"Overview"},{"location":"#installing","text":"pip install repository-orm","title":"Installing"},{"location":"#a-simple-example","text":"from repository_orm import Entity , load_repository repo = load_repository () class Author ( Entity ): id_ : int first_name : str last_name : str country : str author = Author ( id_ = 0 , first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( Author , 0 ) assert brandon == author # Search entities brandon = repo . search ( Author , { \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ( Author )) == 0 # noqa","title":"A Simple Example"},{"location":"#usage","text":"The different repositories share the following operations: add Add an Entity object to the repository, if it already exist, update the stored attributes. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Get all the entities of type Entity from the repository. search Get the entities whose attributes match a condition or regular expression. first Get the first entity in the repository. last Get the first entity in the repository. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() .","title":"Usage"},{"location":"#repositories","text":"To change the repository you only need to change the url passed to load_repository . We have the next repositories: FakeRepository : is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. TinyDBRepository : is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. PypikaRepository : is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases.","title":"Repositories"},{"location":"#references","text":"As most open sourced programs, repository-orm is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . TinyDB Used to interact with the NoSQL database in the TinyDBRepository Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to repository-orm , see Contributing to repository-orm .","title":"Contributing"},{"location":"contributing/","text":"So you've started using repository-orm and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_orm.version; print(repository_orm.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-orm or know it's not relevant to your question or feature request. Pull Requests \u00b6 repository-orm is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-orm.git cd repository-orm Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-orm, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-orm uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-orm !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_orm.version; print(repository_orm.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-orm or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"repository-orm is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-orm.git cd repository-orm Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-orm, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-orm uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-orm !","title":"Development facilities"},{"location":"fake_repository/","text":"The FakeRepository is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. It stores the persisted Entities in the entities object attribute in a dictionary where the keys are the Entity class and the values are list of that Entity objects. When you try to make changes to the repository, the actual entities dictionary is copied to the new_entities attribute. The changes are made on that new attribute and once you use the commit method, they get copied back to the entities attribute. Load it with: from repository_orm import load_repository repo = load_repository () Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to the new_entities attribute. delete Deletes the Entity object from the new_entities attribute. get Obtain an Entity from the entities attribute by it's ID. commit Persist the changes of new_entities into entities , clearing up new_entities afterwards. all Obtain all the entities of type Entity from the entities attribute. search Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. apply_migrations Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing. Simulating errors \u00b6 ConnectionError \u00b6 To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"FakeRepository"},{"location":"fake_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to the new_entities attribute. delete Deletes the Entity object from the new_entities attribute. get Obtain an Entity from the entities attribute by it's ID. commit Persist the changes of new_entities into entities , clearing up new_entities afterwards. all Obtain all the entities of type Entity from the entities attribute. search Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. apply_migrations Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing.","title":"Features"},{"location":"fake_repository/#simulating-errors","text":"","title":"Simulating errors"},{"location":"fake_repository/#connectionerror","text":"To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"ConnectionError"},{"location":"models/","text":"When modeling the application logic through Domain Driven Design , you usually need the following object types: Value object : Any domain object that is uniquely identified by the data it holds, so it has no conceptual identity. They should be treated as immutable. We can still have complex behaviour in value objects. In fact, it's common to support operations, for example, mathematical operators. Entity : An object that is not defined by it's attributes, but rather by a thread of continuity and it's identity. Unlike values, they have identity equality . We can change their values, and they are still recognizably the same thing. Entities \u00b6 We've created the Entity class based on the pydantic's BaseModel to enforce that they have the integer id_ attribute, used for comparison and hashing of entities. They also have a private _model_name attribute with the name of the model.","title":"Models"},{"location":"models/#entities","text":"We've created the Entity class based on the pydantic's BaseModel to enforce that they have the integer id_ attribute, used for comparison and hashing of entities. They also have a private _model_name attribute with the name of the model.","title":"Entities"},{"location":"new_repo/","text":"First make sure you've read the contributing guidelines . All repository types are run against the same tests . Using the awesome library pytest-cases , we were able to separate the test cases from the test functions. The result is not simple to understand, but bear with me, as once you understand it, you may love it. The test cases are in the cases directory below tests . There are two files: entities.py : Where we define the different Entity objects to test through the methods of the EntityCases class. repositories.py : Where we define the different Repository objects to test through the methods of the RepositoryCases class. The Entity cases, return a factory defined with Factoryboy together with the Entity model, to create arbitrary objects with real values generated through Faker . The Repository cases are a little more complex, each of them returns a tuple with the following objects: db : A storage connection object to run direct queries in the tests. empty_repo : A repository instance without the schema applied. repo : A repository instance with the schema applied. repo_tester : A class to particularize the testing interface to each repository. Each repository needs different assertions to ensure that a functionality works as expected, this fact makes it really difficult to parametrize the tests. The solution I've found is to write the tests Making generic tests for The Entities to test are defined in the The interface definition of all repositories is done at the AbstractRepository class.","title":"Create new repository"},{"location":"pypika_repository/","text":"The PypikaRepository is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases. It stores the persisted Entities into a SQLite database tables ( Mysql support will come in the future ). It uses the Pypika query builder to generate the raw SQL statements and then sends them to the database through an sqlite3 connection. If you're wondering why we don't want to use SQLAlchemy or raw sql statements, check this article. Load it with: from repository_orm import load_repository repo = load_repository ( 'sqlite://path/to/database.db' ) Database schema \u00b6 The repository assumes there is a specific schema, where the table names are the same as the Entity clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example. Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to its table by translating its attributes to the columns. If it already exists, use the upsert statement to update it's attributes in the table. delete Deletes the Entity object from its table by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory. Internal workings \u00b6 This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query. References \u00b6 Pypika documentation Yoyo documentation","title":"PypikaRepository"},{"location":"pypika_repository/#database-schema","text":"The repository assumes there is a specific schema, where the table names are the same as the Entity clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example.","title":"Database schema"},{"location":"pypika_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to its table by translating its attributes to the columns. If it already exists, use the upsert statement to update it's attributes in the table. delete Deletes the Entity object from its table by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory.","title":"Features"},{"location":"pypika_repository/#internal-workings","text":"This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query.","title":"Internal workings"},{"location":"pypika_repository/#references","text":"Pypika documentation Yoyo documentation","title":"References"},{"location":"reference/","text":"repository_orm special \u00b6 Library to ease the implementation of the repository pattern in Python projects.. adapters special \u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ abstract \u00b6 Define the interface of the repositories. AbstractRepository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError first ( self , entity_model ) \u00b6 Get the smallest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Smallest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError last ( self , entity_model ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the biggest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Biggest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository pydantic-model \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , database_url = '' , ** data ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) from error apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity last ( self , entity_model ) \u00b6 Get the greatest entity from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the greatest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ([ entity for _ , entity in self . entities [ entity_model ] . items ()]) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = int ( re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path )) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): try : with open ( database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { database_file } \" ) from error self . connection = sqlite3 . connect ( database_file ) self . connection . create_function ( \"REGEXP\" , 2 , _regexp ) self . cursor = self . connection . cursor () add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) try : entities = self . _build_entities ( entity_model , query ) except OperationalError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) from error if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities tinydb \u00b6 Define the TinyDB Repository. TinyDBRepository \u00b6 Implement the repository pattern using the TinyDB. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Attributes: Name Type Description database_url URL specifying the connection to the database. Source code in repository_orm/adapters/tinydb.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes. Attributes: database_url: URL specifying the connection to the database. \"\"\" super () . __init__ ( database_url ) self . database_file = database_url . replace ( \"tinydb:///\" , \"\" ) if not os . path . isfile ( self . database_file ): try : with open ( self . database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { self . database_file } \" ) from error serialization = SerializationMiddleware ( JSONStorage ) serialization . register_serializer ( DateTimeSerializer (), \"TinyDate\" ) self . db_ = TinyDB ( self . database_file , storage = serialization , sort_keys = True , indent = 4 ) self . staged : Dict [ str , List [ Any ]] = { \"add\" : [], \"remove\" : []} add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] entities_data = self . db_ . search ( Query () . model_type_ == entity_model . __name__ . lower () ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), Query () . model_type_ == entity . _model_name . lower (), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/tinydb.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity_data = self . db_ . search ( ( Query () . id_ == entity_id ) & ( Query () . model_type_ == entity_model . __name__ . lower ()) )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error return self . _build_entity ( entity_data , entity_model ) search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] query = Query () . model_type_ == entity_model . __name__ . lower () for key , value in fields . items (): if isinstance ( value , str ): query = query & ( Query ()[ key ] . search ( value )) else : query = query & ( Query ()[ key ] == value ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities config \u00b6 Define the configuration of the main program. exceptions \u00b6 Module to store the repository-orm exceptions. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails. model \u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ > other . id_ __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __init__ ( self , ** data ) special \u00b6 Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__ __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ < other . id_ services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. load_repository ( database_url = None ) \u00b6 Load the Repository object that matches the database_url protocol. Parameters: Name Type Description Default database_url Optional[str] Url to connect to the storage backend. None Returns: Type Description Union[repository_orm.adapters.fake.FakeRepository, repository_orm.adapters.pypika.PypikaRepository, repository_orm.adapters.tinydb.TinyDBRepository] Repository that understands the url protocol. Source code in repository_orm/services.py def load_repository ( database_url : Optional [ str ] = None ) -> Repository : \"\"\"Load the Repository object that matches the database_url protocol. Args: database_url: Url to connect to the storage backend. Returns: Repository that understands the url protocol. \"\"\" if database_url is None or \"fake://\" in database_url : repo : Repository = FakeRepository () elif \"sqlite://\" in database_url : repo = PypikaRepository ( database_url ) elif \"tinydb://\" in database_url : repo = TinyDBRepository ( database_url ) return repo version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in repository_orm/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_orm version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#repository_orm","text":"Library to ease the implementation of the repository pattern in Python projects..","title":"repository_orm"},{"location":"reference/#repository_orm.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"adapters"},{"location":"reference/#repository_orm.adapters.abstract","text":"Define the interface of the repositories.","title":"abstract"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"AbstractRepository"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url","title":"__init__()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError","title":"add()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.first","text":"Get the smallest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Smallest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error","title":"first()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the biggest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Biggest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error","title":"last()"},{"location":"reference/#repository_orm.adapters.abstract.AbstractRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference/#repository_orm.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" )","title":"__init__()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) from error","title":"all()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity","title":"get()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.last","text":"Get the greatest entity from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the greatest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ([ entity for _ , entity in self . entities [ entity_model ] . items ()]) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository.\" ) from error","title":"last()"},{"location":"reference/#repository_orm.adapters.fake.FakeRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = int ( re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path )) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities","title":"search()"},{"location":"reference/#repository_orm.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): try : with open ( database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { database_file } \" ) from error self . connection = sqlite3 . connect ( database_file ) self . connection . create_function ( \"REGEXP\" , 2 , _regexp ) self . cursor = self . connection . cursor ()","title":"__init__()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query )","title":"add()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities","title":"all()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error","title":"get()"},{"location":"reference/#repository_orm.adapters.pypika.PypikaRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) try : entities = self . _build_entities ( entity_model , query ) except OperationalError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) from error if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference/#repository_orm.adapters.tinydb","text":"Define the TinyDB Repository.","title":"tinydb"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository","text":"Implement the repository pattern using the TinyDB.","title":"TinyDBRepository"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.__init__","text":"Initialize the repository attributes. Attributes: Name Type Description database_url URL specifying the connection to the database. Source code in repository_orm/adapters/tinydb.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes. Attributes: database_url: URL specifying the connection to the database. \"\"\" super () . __init__ ( database_url ) self . database_file = database_url . replace ( \"tinydb:///\" , \"\" ) if not os . path . isfile ( self . database_file ): try : with open ( self . database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { self . database_file } \" ) from error serialization = SerializationMiddleware ( JSONStorage ) serialization . register_serializer ( DateTimeSerializer (), \"TinyDate\" ) self . db_ = TinyDB ( self . database_file , storage = serialization , sort_keys = True , indent = 4 ) self . staged : Dict [ str , List [ Any ]] = { \"add\" : [], \"remove\" : []}","title":"__init__()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity )","title":"add()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] entities_data = self . db_ . search ( Query () . model_type_ == entity_model . __name__ . lower () ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities","title":"all()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), Query () . model_type_ == entity . _model_name . lower (), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear ()","title":"commit()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity )","title":"delete()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/tinydb.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity_data = self . db_ . search ( ( Query () . id_ == entity_id ) & ( Query () . model_type_ == entity_model . __name__ . lower ()) )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error return self . _build_entity ( entity_data , entity_model )","title":"get()"},{"location":"reference/#repository_orm.adapters.tinydb.TinyDBRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] query = Query () . model_type_ == entity_model . __name__ . lower () for key , value in fields . items (): if isinstance ( value , str ): query = query & ( Query ()[ key ] . search ( value )) else : query = query & ( Query ()[ key ] == value ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference/#repository_orm.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#repository_orm.exceptions","text":"Module to store the repository-orm exceptions.","title":"exceptions"},{"location":"reference/#repository_orm.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference/#repository_orm.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference/#repository_orm.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository.","title":"Entity"},{"location":"reference/#repository_orm.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ > other . id_","title":"__gt__()"},{"location":"reference/#repository_orm.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference/#repository_orm.model.Entity.__init__","text":"Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__","title":"__init__()"},{"location":"reference/#repository_orm.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ < other . id_","title":"__lt__()"},{"location":"reference/#repository_orm.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#repository_orm.services.load_repository","text":"Load the Repository object that matches the database_url protocol. Parameters: Name Type Description Default database_url Optional[str] Url to connect to the storage backend. None Returns: Type Description Union[repository_orm.adapters.fake.FakeRepository, repository_orm.adapters.pypika.PypikaRepository, repository_orm.adapters.tinydb.TinyDBRepository] Repository that understands the url protocol. Source code in repository_orm/services.py def load_repository ( database_url : Optional [ str ] = None ) -> Repository : \"\"\"Load the Repository object that matches the database_url protocol. Args: database_url: Url to connect to the storage backend. Returns: Repository that understands the url protocol. \"\"\" if database_url is None or \"fake://\" in database_url : repo : Repository = FakeRepository () elif \"sqlite://\" in database_url : repo = PypikaRepository ( database_url ) elif \"tinydb://\" in database_url : repo = TinyDBRepository ( database_url ) return repo","title":"load_repository()"},{"location":"reference/#repository_orm.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#repository_orm.version.version_info","text":"Display the version of the program, python and the platform. Source code in repository_orm/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_orm version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"reference_adapters/","text":"repository_orm.adapters special \u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ abstract \u00b6 Define the interface of the repositories. AbstractRepository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError first ( self , entity_model ) \u00b6 Get the smallest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Smallest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError last ( self , entity_model ) \u00b6 Get the biggest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the biggest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Biggest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository pydantic-model \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , database_url = '' , ** data ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" ) add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) from error apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity last ( self , entity_model ) \u00b6 Get the greatest entity from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the greatest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ([ entity for _ , entity in self . entities [ entity_model ] . items ()]) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = int ( re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path )) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Source code in repository_orm/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): try : with open ( database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { database_file } \" ) from error self . connection = sqlite3 . connect ( database_file ) self . connection . create_function ( \"REGEXP\" , 2 , _regexp ) self . cursor = self . connection . cursor () add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) try : entities = self . _build_entities ( entity_model , query ) except OperationalError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) from error if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities tinydb \u00b6 Define the TinyDB Repository. TinyDBRepository \u00b6 Implement the repository pattern using the TinyDB. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Attributes: Name Type Description database_url URL specifying the connection to the database. Source code in repository_orm/adapters/tinydb.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes. Attributes: database_url: URL specifying the connection to the database. \"\"\" super () . __init__ ( database_url ) self . database_file = database_url . replace ( \"tinydb:///\" , \"\" ) if not os . path . isfile ( self . database_file ): try : with open ( self . database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { self . database_file } \" ) from error serialization = SerializationMiddleware ( JSONStorage ) serialization . register_serializer ( DateTimeSerializer (), \"TinyDate\" ) self . db_ = TinyDB ( self . database_file , storage = serialization , sort_keys = True , indent = 4 ) self . staged : Dict [ str , List [ Any ]] = { \"add\" : [], \"remove\" : []} add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] entities_data = self . db_ . search ( Query () . model_type_ == entity_model . __name__ . lower () ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), Query () . model_type_ == entity . _model_name . lower (), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/tinydb.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity_data = self . db_ . search ( ( Query () . id_ == entity_id ) & ( Query () . model_type_ == entity_model . __name__ . lower ()) )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error return self . _build_entity ( entity_data , entity_model ) search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] query = Query () . model_type_ == entity_model . __name__ . lower () for key , value in fields . items (): if isinstance ( value , str ): query = query & ( Query ()[ key ] . search ( value )) else : query = query & ( Query ()[ key ] == value ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"Repository Implementations"},{"location":"reference_adapters/#repository_orm.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"adapters"},{"location":"reference_adapters/#repository_orm.adapters.abstract","text":"Define the interface of the repositories.","title":"abstract"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"AbstractRepository"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" # no cover: it's tested by it's subclasses if entity . id_ < 0 : # pragma: no cover entity . id_ = self . _next_id ( entity ) # pragma: no cover raise NotImplementedError","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.first","text":"Get the smallest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def first ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the smallest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Smallest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return min ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error","title":"first()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.last","text":"Get the biggest entity from the repository. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/abstract.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the biggest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Biggest Entity object of type entity_model. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ( self . all ( entity_model )) except KeyError as error : # no cover: it's tested by it's subclasses raise EntityNotFoundError ( # pragma: no cover f \"There are no { entity_model . __name__ } s in the repository.\" ) from error","title":"last()"},{"location":"reference_adapters/#repository_orm.adapters.abstract.AbstractRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_orm.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_orm.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/abstract.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"/inexistent_dir/database.db\" : raise ConnectionError ( f \"Could not create database file: { database_url } \" )","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) from error","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.last","text":"Get the greatest entity from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If there are no entities. Source code in repository_orm/adapters/fake.py def last ( self , entity_model : Type [ Entity ]) -> Entity : \"\"\"Get the greatest entity from the repository. Args: entity_model: Type of entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If there are no entities. \"\"\" try : return max ([ entity for _ , entity in self . entities [ entity_model ] . items ()]) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository.\" ) from error","title":"last()"},{"location":"reference_adapters/#repository_orm.adapters.fake.FakeRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = int ( re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path )) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] return entities","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.__init__","text":"Initialize the repository attributes. Source code in repository_orm/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): try : with open ( database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { database_file } \" ) from error self . connection = sqlite3 . connect ( database_file ) self . connection . create_function ( \"REGEXP\" , 2 , _regexp ) self . cursor = self . connection . cursor ()","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] insert_query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) # Until https://github.com/kayak/pypika/issues/535 is solved we need to write # The upsert statement ourselves. # nosec: B608:hardcoded_sql_expressions, Possible SQL injection vector through # string-based query construction. We're not letting the user define the # values of the query, the only variable inputs are the keys, that are # defined by the developer, so it's not probable that he chooses an # entity attributes that are an SQL injection. Once the #535 issue is # solved, we should get rid of this error too. upsert_query = ( str ( insert_query ) + \" ON CONFLICT(id) DO UPDATE SET \" # nosec + \", \" . join ([ f \" { key } =excluded. { key } \" for key in columns ]) ) self . _execute ( upsert_query )","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.pypika.PypikaRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" if isinstance ( value , str ): query = query . where ( getattr ( table , key ) . regexp ( value )) else : query = query . where ( getattr ( table , key ) == value ) try : entities = self . _build_entities ( entity_model , query ) except OperationalError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) from error if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb","text":"Define the TinyDB Repository.","title":"tinydb"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository","text":"Implement the repository pattern using the TinyDB.","title":"TinyDBRepository"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.__init__","text":"Initialize the repository attributes. Attributes: Name Type Description database_url URL specifying the connection to the database. Source code in repository_orm/adapters/tinydb.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes. Attributes: database_url: URL specifying the connection to the database. \"\"\" super () . __init__ ( database_url ) self . database_file = database_url . replace ( \"tinydb:///\" , \"\" ) if not os . path . isfile ( self . database_file ): try : with open ( self . database_file , \"a\" ) as file_cursor : file_cursor . close () except FileNotFoundError as error : raise ConnectionError ( f \"Could not create the database file: { self . database_file } \" ) from error serialization = SerializationMiddleware ( JSONStorage ) serialization . register_serializer ( DateTimeSerializer (), \"TinyDate\" ) self . db_ = TinyDB ( self . database_file , storage = serialization , sort_keys = True , indent = 4 ) self . staged : Dict [ str , List [ Any ]] = { \"add\" : [], \"remove\" : []}","title":"__init__()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity ~Entity Entity to add to the repository. required Source code in repository_orm/adapters/tinydb.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if entity . id_ < 0 : entity . id_ = self . _next_id ( entity ) self . staged [ \"add\" ] . append ( entity )","title":"add()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity objects to obtain. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] entities_data = self . db_ . search ( Query () . model_type_ == entity_model . __name__ . lower () ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } entities in the repository\" ) return entities","title":"all()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_orm/adapters/tinydb.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.commit","text":"Persist the changes into the repository. Source code in repository_orm/adapters/tinydb.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity in self . staged [ \"add\" ]: self . db_ . upsert ( self . _export_entity ( entity ), Query () . model_type_ == entity . _model_name . lower (), ) self . staged [ \"add\" ] . clear () for entity in self . staged [ \"remove\" ]: self . db_ . remove ( ( Query () . model_type_ == entity . _model_name . lower ()) & ( Query () . id_ == entity . id_ ) ) self . staged [ \"remove\" ] . clear ()","title":"commit()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity ~Entity Entity to remove from the repository. required Source code in repository_orm/adapters/tinydb.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error self . staged [ \"remove\" ] . append ( entity )","title":"delete()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description ~Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_orm/adapters/tinydb.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity_data = self . db_ . search ( ( Query () . id_ == entity_id ) & ( Query () . model_type_ == entity_model . __name__ . lower ()) )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error return self . _build_entity ( entity_data , entity_model )","title":"get()"},{"location":"reference_adapters/#repository_orm.adapters.tinydb.TinyDBRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[~Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[~Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_orm/adapters/tinydb.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" entities = [] query = Query () . model_type_ == entity_model . __name__ . lower () for key , value in fields . items (): if isinstance ( value , str ): query = query & ( Query ()[ key ] . search ( value )) else : query = query & ( Query ()[ key ] == value ) entities_data = self . db_ . search ( query ) for entity_data in entities_data : entities . append ( self . _build_entity ( entity_data , entity_model )) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference_exceptions/","text":"repository_orm.exceptions \u00b6 Module to store the repository-orm exceptions. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails.","title":"Exceptions"},{"location":"reference_exceptions/#repository_orm.exceptions","text":"Module to store the repository-orm exceptions.","title":"exceptions"},{"location":"reference_exceptions/#repository_orm.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference_models/","text":"repository_orm.model \u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ > other . id_ __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __init__ ( self , ** data ) special \u00b6 Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__ __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ < other . id_","title":"Models"},{"location":"reference_models/#repository_orm.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference_models/#repository_orm.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. An entity with a negative id means that the id needs to be set by the repository.","title":"Entity"},{"location":"reference_models/#repository_orm.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ > other . id_","title":"__gt__()"},{"location":"reference_models/#repository_orm.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_orm/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference_models/#repository_orm.model.Entity.__init__","text":"Set the _model_name attribute. Source code in repository_orm/model.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Set the _model_name attribute.\"\"\" super () . __init__ ( ** data ) self . _model_name = self . __class__ . __name__","title":"__init__()"},{"location":"reference_models/#repository_orm.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_orm/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . id_ < other . id_","title":"__lt__()"},{"location":"tinydb_repository/","text":"The TinyDBRepository is the implementation of the repository pattern for the local NoSQL TinyDB database. You can use it in the early stages of the project where the data schema is yet unstable and you don't have enough entities to have performance issues. It stores the persisted Entities into a json file. Load it with: from repository_orm import load_repository repo = load_repository ( 'tinydb://path/to/database.db' ) Features \u00b6 Follow the overview example to see how to use each method. add Appends the Entity object to the default table by translating its attributes to a valid json row. If it already exists, it uses the upsert statement to update it's attributes in the table. delete Deletes the Entity object from the collection by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations We don't yet support migrations on the schema , so the models should be flexible enough to absorb the changes, or you can code your migrations in your program, or even better, help us solve #27 . Internal workings \u00b6 This section is meant for the people that you to expand the functionality of the TinyDBRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format tinydb:///path_to_database_file , an TinyDB object is created in the db_ attribute, the path to the database is saved in database_file and a empty dictionary of staged changes is created in staged . Saving entities \u00b6 All entities are saved in the same default table _default , to avoid id_ collision, before storing the objects, an model_type_ attribute is appended with the lowercase name of the entity class. When retrieving objects with get and all , the attribute is deleted. Committing \u00b6 TinyDB doesn't have the concept of transactions, the tinyrecord plugin does, but you need to run everything in the same context manager, which doesn't suit our case. So whenever we add or remove an entity from the repository, they are stored in the staged attribute, and once commit is called, they are persisted into the database. References \u00b6 TinyDB documentation","title":"TinyDBRepository"},{"location":"tinydb_repository/#features","text":"Follow the overview example to see how to use each method. add Appends the Entity object to the default table by translating its attributes to a valid json row. If it already exists, it uses the upsert statement to update it's attributes in the table. delete Deletes the Entity object from the collection by searching the row that matches the object ID. get Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. commit Persist the changes into the database. all Obtain all the entities of type Entity . Similar to the get method but for all entities. search Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. apply_migrations We don't yet support migrations on the schema , so the models should be flexible enough to absorb the changes, or you can code your migrations in your program, or even better, help us solve #27 .","title":"Features"},{"location":"tinydb_repository/#internal-workings","text":"This section is meant for the people that you to expand the functionality of the TinyDBRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format tinydb:///path_to_database_file , an TinyDB object is created in the db_ attribute, the path to the database is saved in database_file and a empty dictionary of staged changes is created in staged .","title":"Internal workings"},{"location":"tinydb_repository/#saving-entities","text":"All entities are saved in the same default table _default , to avoid id_ collision, before storing the objects, an model_type_ attribute is appended with the lowercase name of the entity class. When retrieving objects with get and all , the attribute is deleted.","title":"Saving entities"},{"location":"tinydb_repository/#committing","text":"TinyDB doesn't have the concept of transactions, the tinyrecord plugin does, but you need to run everything in the same context manager, which doesn't suit our case. So whenever we add or remove an entity from the repository, they are stored in the staged attribute, and once commit is called, they are persisted into the database.","title":"Committing"},{"location":"tinydb_repository/#references","text":"TinyDB documentation","title":"References"},{"location":"adr/001-entity_id_definition/","text":"Status \u00b6 Accepted Context \u00b6 Right now the Entity class has a mandatory id_ attribute of types str or int . That prevents the user to create entities a model level as they are not aware of the existent entities in the repository. Proposals \u00b6 We can: Assume that the model functions that create the new entities receive the new entity id as an argument. Change the definition of the id_ attribute so that it can be set by the repository at the moment of adding it to the repository. I've started using the first in pydo and found it cumbersome. The first approximation for the second can be to assume that the id_ is an integer, by default is set to a negative value, marking it as invalid, and when the repository sees it, gets the last id and increments it in a unit. This can't be easily done if the id_ is a str . So I'm temporarily dropping support for this types of IDs. If anyone needs them, we can create a workaround like converting them to an ascii integer and increasing it by one. If we want more complex objects to be used as ids, we may think of letting the user specify a callable to increase the ids. Decision \u00b6 We're setting a default id_ value of -1 on Entities, the repository will react to these ids, getting the last valid ID and increasing it by one. Consequences \u00b6 As a side effect, we're temporarily dropping support for str id_ attributes.","title":"Status"},{"location":"adr/001-entity_id_definition/#status","text":"Accepted","title":"Status"},{"location":"adr/001-entity_id_definition/#context","text":"Right now the Entity class has a mandatory id_ attribute of types str or int . That prevents the user to create entities a model level as they are not aware of the existent entities in the repository.","title":"Context"},{"location":"adr/001-entity_id_definition/#proposals","text":"We can: Assume that the model functions that create the new entities receive the new entity id as an argument. Change the definition of the id_ attribute so that it can be set by the repository at the moment of adding it to the repository. I've started using the first in pydo and found it cumbersome. The first approximation for the second can be to assume that the id_ is an integer, by default is set to a negative value, marking it as invalid, and when the repository sees it, gets the last id and increments it in a unit. This can't be easily done if the id_ is a str . So I'm temporarily dropping support for this types of IDs. If anyone needs them, we can create a workaround like converting them to an ascii integer and increasing it by one. If we want more complex objects to be used as ids, we may think of letting the user specify a callable to increase the ids.","title":"Proposals"},{"location":"adr/001-entity_id_definition/#decision","text":"We're setting a default id_ value of -1 on Entities, the repository will react to these ids, getting the last valid ID and increasing it by one.","title":"Decision"},{"location":"adr/001-entity_id_definition/#consequences","text":"As a side effect, we're temporarily dropping support for str id_ attributes.","title":"Consequences"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: Entity ID definition] click 001 \"https://lyz-code.github.io/repository-orm/adr/001-entity_id_definition/\" _blank 001:::accepted classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Architecture Decision Records"}]}