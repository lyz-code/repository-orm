{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Library to ease the implementation of the repository pattern in python projects. The repository pattern is an abstraction over persistent storage, allowing us to decouple our model layer from the data layer. It hides the boring details of data access by pretending that all of our data is in memory. It has the following advantages: We get a simple interface, which we control, between persistent storage and our domain model. It's easy to make a fake version of the repository for unit testing, or to swap out different storage solutions, because we've fully decoupled the model from infrastructure concerns. Writing the domain model before thinking about persistence helps us focus on the business problem at hand. If we need to change our approach, we can do that in our model, without needing to worry about foreign keys or migrations until later. Our database schema is simple because we have complete control over how we map our object to tables. Speeds up and makes more clean the business logic tests. It's easy to implement. But the following disadvantages: An ORM already buys you some decoupling. Changing foreign keys might be hard, but it should be pretty easy to swap between MySQL and Postres if you ever need to. Maintaining ORM mappings by hand requires extra work and extra code. An extra layer of abstraction is introduced, and although we may hope it will reduce complexity overall, it does add complexity locally. Furthermore it adds the WTF factor for Python programmers who've never seen this pattern before. repository-pattern aims to mitigate the last ones by: Supplying classes that already have the common operations for different storage solutions. Supplying test classes and fixtures so extending the provided repositories is easy. Installing \u00b6 pip install repository-pattern A Simple Example \u00b6 from repository_pattern import Entity , FakeRepository repo = FakeRepository () class Author ( Entity ): id_ : int first_name : str last_name : str country : str author = Author ( id_ = 0 , first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( Author , 0 ) assert brandon == author # Search entities brandon = repo . search ( Author , { \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ( Author )) == 0 # noqa Usage \u00b6 The different repositories share the following operations: add Add an Entity object to the repository. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Obtain all the entities of type Entity from the repository. search Obtain the entities whose attributes match a condition. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() . References \u00b6 As most open sourced programs, repository_pattern is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to repository-pattern , see Contributing to repository-pattern .","title":"Overview"},{"location":"#installing","text":"pip install repository-pattern","title":"Installing"},{"location":"#a-simple-example","text":"from repository_pattern import Entity , FakeRepository repo = FakeRepository () class Author ( Entity ): id_ : int first_name : str last_name : str country : str author = Author ( id_ = 0 , first_name = \"Brandon\" , last_name = \"Sanderson\" , country = \"US\" ) # Add entities repo . add ( author ) repo . commit () # Retrieve entities by their ID brandon = repo . get ( Author , 0 ) assert brandon == author # Search entities brandon = repo . search ( Author , { \"first_name\" : \"Brandon\" })[ 0 ] assert brandon == author # Delete entities repo . delete ( brandon ) repo . commit () assert len ( repo . all ( Author )) == 0 # noqa","title":"A Simple Example"},{"location":"#usage","text":"The different repositories share the following operations: add Add an Entity object to the repository. delete Remove an Entity object form the repository. get Obtain an Entity from the repository by it's ID. commit Persist the changes into the repository. all Obtain all the entities of type Entity from the repository. search Obtain the entities whose attributes match a condition. apply_migrations Run the migrations of the repository schema. Changes in the repository aren't persisted until you run repo.commit() .","title":"Usage"},{"location":"#references","text":"As most open sourced programs, repository_pattern is standing on the shoulders of giants, namely: pydantic Used for the Entities definition. DeepDiff Used to search strings in complex objects in the FakeRepository . Pypika Used to build the SQL queries in the PypikaRepository . Yoyo Used to manage the schema changes of the PypikaRepository . Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to repository-pattern , see Contributing to repository-pattern .","title":"Contributing"},{"location":"contributing/","text":"So you've started using repository-pattern and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_pattern.version; print(repository_pattern.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-pattern or know it's not relevant to your question or feature request. Pull Requests \u00b6 repository-pattern is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-pattern.git cd repository-pattern Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-pattern, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-pattern uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-pattern !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import repository_pattern.version; print(repository_pattern.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install repository-pattern or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"repository-pattern is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/repository-pattern.git cd repository-pattern Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install repository-pattern, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: repository-pattern uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to repository-pattern !","title":"Development facilities"},{"location":"fake_repository/","text":"The [ FakeRepository ][repository_pattern.adapters.fake.FakeRepository] is the simplest implementation of the repository pattern, meant to be used for the tests and early phases of development. It stores the persisted [Entities][repository_pattern.model.Entity] in the entities object attribute in a dictionary where the keys are the Entity class and the values are list of that Entity objects. When you try to make changes to the repository, the actual entities dictionary is copied to the new_entities attribute. The changes are made on that new attribute and once you use the commit method, they get copied back to the entities attribute. Features \u00b6 Follow the overview example to see how to use each method. [ add ][repository_pattern.adapters.fake.FakeRepository.add] Appends the Entity object to the new_entities attribute. [ delete ][repository_pattern.adapters.fake.FakeRepository.delete] Deletes the Entity object from the new_entities attribute. [ get ][repository_pattern.adapters.fake.FakeRepository.get] Obtain an Entity from the entities attribute by it's ID. [ commit ][repository_pattern.adapters.fake.FakeRepository.commit] Persist the changes of new_entities into entities , clearing up new_entities afterwards. [ all ][repository_pattern.adapters.fake.FakeRepository.all] Obtain all the entities of type Entity from the entities attribute. [ search ][repository_pattern.adapters.fake.FakeRepository.search] Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. [ apply_migrations ][repository_pattern.adapters.fake.FakeRepository.apply_migrations] Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing. Simulating errors \u00b6 ConnectionError \u00b6 To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"FakeRepository"},{"location":"fake_repository/#features","text":"Follow the overview example to see how to use each method. [ add ][repository_pattern.adapters.fake.FakeRepository.add] Appends the Entity object to the new_entities attribute. [ delete ][repository_pattern.adapters.fake.FakeRepository.delete] Deletes the Entity object from the new_entities attribute. [ get ][repository_pattern.adapters.fake.FakeRepository.get] Obtain an Entity from the entities attribute by it's ID. [ commit ][repository_pattern.adapters.fake.FakeRepository.commit] Persist the changes of new_entities into entities , clearing up new_entities afterwards. [ all ][repository_pattern.adapters.fake.FakeRepository.all] Obtain all the entities of type Entity from the entities attribute. [ search ][repository_pattern.adapters.fake.FakeRepository.search] Obtain the entities whose attributes match one or multiple conditions. We use DeepDiff's grep to search for the entities that have the value we're searching for and then we search if the key of those entities match the one we're searching for. [ apply_migrations ][repository_pattern.adapters.fake.FakeRepository.apply_migrations] Run the migrations of the repository schema. As the fake repository doesn't have any schema this method does nothing.","title":"Features"},{"location":"fake_repository/#simulating-errors","text":"","title":"Simulating errors"},{"location":"fake_repository/#connectionerror","text":"To simulate a connection error to the database, initialize the object with the wrong_database_url string.","title":"ConnectionError"},{"location":"models/","text":"When modeling the application logic through Domain Driven Design , you usually need the following object types: Value object : Any domain object that is uniquely identified by the data it holds, so it has no conceptual identity. They should be treated as immutable. We can still have complex behaviour in value objects. In fact, it's common to support operations, for example, mathematical operators. Entity : An object that is not defined by it's attributes, but rather by a thread of continuity and it's identity. Unlike values, they have identity equality . We can change their values, and they are still recognizably the same thing. Entities \u00b6 We've created the [Entity][repository_pattern.model.Entity] class based on the pydantic's BaseModel to enforce that they have the id_ attribute and they can be compared and hashed based on that attribute.","title":"Models"},{"location":"models/#entities","text":"We've created the [Entity][repository_pattern.model.Entity] class based on the pydantic's BaseModel to enforce that they have the id_ attribute and they can be compared and hashed based on that attribute.","title":"Entities"},{"location":"new_repo/","text":"First make sure you've read the contributing guidelines . All repository types are run against the same tests . Using the awesome library pytest-cases , we were able to separate the test cases from the test functions. The result is not simple to understand, but bear with me, as once you understand it, you may love it. The test cases are in the cases directory below tests . There are two files: entities.py : Where we define the different Entity objects to test through the methods of the EntityCases class. repositories.py : Where we define the different Repository objects to test through the methods of the RepositoryCases class. The Entity cases, return a factory defined with Factoryboy together with the Entity model, to create arbitrary objects with real values generated through Faker . The Repository cases are a little more complex, each of them returns a tuple with the following objects: db : A storage connection object to run direct queries in the tests. empty_repo : A repository instance without the schema applied. repo : A repository instance with the schema applied. repo_tester : A class to particularize the testing interface to each repository. Each repository needs different assertions to ensure that a functionality works as expected, this fact makes it really difficult to parametrize the tests. The solution I've found is to write the tests Making generic tests for The Entities to test are defined in the The interface definition of all repositories is done at the [AbstractRepository][repository_pattern.adapters.AbstractRepository] class.","title":"Create new repository"},{"location":"pypika_repository/","text":"The [ PypikaRepository ][repository_pattern.adapters.pypika.PypikaRepository] is the implementation of the repository pattern for the relational databases. It's meant for the stages of the project where the schema is more stable and you need the improved performance of these types of databases. It stores the persisted [Entities][repository_pattern.model.Entity] into a SQLite database tables ( Mysql support will come in the future ). It uses the Pypika query builder to generate the raw SQL statements and then sends them to the database through an sqlite3 connection. If you're wondering why we don't want to use SQLAlchemy or raw sql statements, check this article. Database schema \u00b6 The repository assumes there is a specific schema, where the table names are the same as the [Entity][repository_pattern.model.Entity] clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example. Features \u00b6 Follow the overview example to see how to use each method. [ add ][repository_pattern.adapters.pypika.PypikaRepository.add] Appends the Entity object to its table by translating its attributes to the columns. [ delete ][repository_pattern.adapters.pypika.PypikaRepository.delete] Deletes the Entity object from its table by searching the row that matches the object ID. [ get ][repository_pattern.adapters.pypika.PypikaRepository.get] Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. [ commit ][repository_pattern.adapters.pypika.PypikaRepository.commit] Persist the changes into the database. [ all ][repository_pattern.adapters.pypika.PypikaRepository.all] Obtain all the entities of type Entity . Similar to the get method but for all entities. [ search ][repository_pattern.adapters.pypika.PypikaRepository.search] Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. [ apply_migrations ][repository_pattern.adapters.pypika.PypikaRepository.apply_migrations] Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory. Internal workings \u00b6 This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query. References \u00b6 Pypika documentation Yoyo documentation","title":"PypikaRepository"},{"location":"pypika_repository/#database-schema","text":"The repository assumes there is a specific schema, where the table names are the same as the [Entity][repository_pattern.model.Entity] clases in lowercase, and the columns are called as the attributes. All tables must have an id column. Following the overview example , the database should contain one table called author with the columns id , first_name , last_name and country . For it's simplicity, we've decide to use yoyo to maintain the schema. This means that you need to write the migration scripts yourself :(. Look at the migration script of the tests if you need an example.","title":"Database schema"},{"location":"pypika_repository/#features","text":"Follow the overview example to see how to use each method. [ add ][repository_pattern.adapters.pypika.PypikaRepository.add] Appends the Entity object to its table by translating its attributes to the columns. [ delete ][repository_pattern.adapters.pypika.PypikaRepository.delete] Deletes the Entity object from its table by searching the row that matches the object ID. [ get ][repository_pattern.adapters.pypika.PypikaRepository.get] Obtain an Entity by extracting the row that matches the ID and build the Entity object with that data. [ commit ][repository_pattern.adapters.pypika.PypikaRepository.commit] Persist the changes into the database. [ all ][repository_pattern.adapters.pypika.PypikaRepository.all] Obtain all the entities of type Entity . Similar to the get method but for all entities. [ search ][repository_pattern.adapters.pypika.PypikaRepository.search] Obtain the entities whose attributes match one or multiple conditions. We create a query with all the desired criteria and then build the entities with the obtained data. [ apply_migrations ][repository_pattern.adapters.pypika.PypikaRepository.apply_migrations] Run the migrations of the repository schema. Creates a yoyo connection and runs all the scripts in the migrations directory.","title":"Features"},{"location":"pypika_repository/#internal-workings","text":"This section is meant for the people that you to expand the functionality of the PypikaRepository. It explains how it works under the hood. Once the object is initialized with the database url with the format sqlite:///path_to_database_file , an sqlite3 Connection object is saved in the connection attribute, and a first Cursor is saved to the cursor attribute. If you need to execute new queries, use the _execute method, it accepts a Pypika Query object. To extract the Pypika Table from an identity object, use the _table static method, or the _table_model if you use an identity class instead. Keep in mind that if you use the internal methods, like _execute , in your program, you're breaking the Liskov substitution principle and you won't be able to switch to other type of repository. If you need a functionality that is not implemented, create a public method and define it for the repositories that you want to use. Take a look at the contributing page, and think of adding it to the library. There is also the _build_entities method that accepts an Entity class and a Query and returns a list of the entities built from the data of the query.","title":"Internal workings"},{"location":"pypika_repository/#references","text":"Pypika documentation Yoyo documentation","title":"References"},{"location":"reference/","text":"\u00b6 Library to ease the implementation of the repository pattern in python projects.. adapters special \u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ AbstractRepository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" raise NotImplementedError all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository pydantic-model \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , database_url = '' , ** data ) special \u00b6 Initialize the repository attributes. Source code in repository_pattern/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"wrong_database_url\" : raise ConnectionError ( f \"There is no database file: { database_url } \" ) add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) from error apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] if len ( entities ) == 0 : raise EntityNotFoundError ( error_msg ) return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Source code in repository_pattern/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): raise ConnectionError ( f \"There is no database file: { database_file } \" ) self . connection = sqlite3 . connect ( database_file ) self . cursor = self . connection . cursor () add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) self . _execute ( query ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" query = query . where ( getattr ( table , key ) == value ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities config \u00b6 Define the configuration of the main program. exceptions \u00b6 Module to store the repository-pattern exceptions. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails. model \u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ > other . id_ # type: ignore __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_pattern/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ < other . id_ # type: ignore services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in repository_pattern/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_pattern version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#repository_pattern","text":"Library to ease the implementation of the repository pattern in python projects..","title":"repository_pattern"},{"location":"reference/#repository_pattern.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"adapters"},{"location":"reference/#repository_pattern.adapters.AbstractRepository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"AbstractRepository"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url","title":"__init__()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" raise NotImplementedError","title":"add()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference/#repository_pattern.adapters.AbstractRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference/#repository_pattern.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_pattern/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"wrong_database_url\" : raise ConnectionError ( f \"There is no database file: { database_url } \" )","title":"__init__()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) from error","title":"all()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity","title":"get()"},{"location":"reference/#repository_pattern.adapters.fake.FakeRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] if len ( entities ) == 0 : raise EntityNotFoundError ( error_msg ) return entities","title":"search()"},{"location":"reference/#repository_pattern.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.__init__","text":"Initialize the repository attributes. Source code in repository_pattern/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): raise ConnectionError ( f \"There is no database file: { database_file } \" ) self . connection = sqlite3 . connect ( database_file ) self . cursor = self . connection . cursor ()","title":"__init__()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) self . _execute ( query )","title":"add()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) return entities","title":"all()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error","title":"get()"},{"location":"reference/#repository_pattern.adapters.pypika.PypikaRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" query = query . where ( getattr ( table , key ) == value ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference/#repository_pattern.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#repository_pattern.exceptions","text":"Module to store the repository-pattern exceptions.","title":"exceptions"},{"location":"reference/#repository_pattern.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference/#repository_pattern.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference/#repository_pattern.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing.","title":"Entity"},{"location":"reference/#repository_pattern.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ > other . id_ # type: ignore","title":"__gt__()"},{"location":"reference/#repository_pattern.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_pattern/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference/#repository_pattern.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ < other . id_ # type: ignore","title":"__lt__()"},{"location":"reference/#repository_pattern.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#repository_pattern.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#repository_pattern.version.version_info","text":"Display the version of the program, python and the platform. Source code in repository_pattern/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository_pattern version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"reference_adapters/","text":"\u00b6 Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/ AbstractRepository \u00b6 Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database. __init__ ( self , database_url = '' ) special \u00b6 Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" raise NotImplementedError all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError fake \u00b6 Store the fake repository implementation. FakeRepository pydantic-model \u00b6 Implement the repository pattern using a memory dictionary. __init__ ( self , database_url = '' , ** data ) special \u00b6 Initialize the repository attributes. Source code in repository_pattern/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"wrong_database_url\" : raise ConnectionError ( f \"There is no database file: { database_url } \" ) add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) from error apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {} delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] if len ( entities ) == 0 : raise EntityNotFoundError ( error_msg ) return entities pypika \u00b6 Define the Pypika Repository. PypikaRepository \u00b6 Implement the repository pattern using the Pypika query builder. __init__ ( self , database_url ) special \u00b6 Initialize the repository attributes. Source code in repository_pattern/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): raise ConnectionError ( f \"There is no database file: { database_file } \" ) self . connection = sqlite3 . connect ( database_file ) self . cursor = self . connection . cursor () add ( self , entity ) \u00b6 Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) self . _execute ( query ) all ( self , entity_model ) \u00b6 Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) return entities apply_migrations ( self , migrations_directory ) \u00b6 Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" ) commit ( self ) \u00b6 Persist the changes into the repository. Source code in repository_pattern/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit () delete ( self , entity ) \u00b6 Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query ) get ( self , entity_model , entity_id ) \u00b6 Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error search ( self , entity_model , fields ) \u00b6 Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" query = query . where ( getattr ( table , key ) == value ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"Repository Implementations"},{"location":"reference_adapters/#repository_pattern.adapters","text":"Module to store the functions shared by the different adapters. Abstract Classes: !!! abstractrepository \"Gathers common methods and define the interface of the\" repositories. References: * https://lyz-code.github.io/blue-book/architecture/repository_pattern/","title":"repository_pattern.adapters"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository","text":"Gather common methods and define the interface of the repositories. Attributes: Name Type Description database_url URL specifying the connection to the database.","title":"AbstractRepository"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.__init__","text":"Initialize the repository attributes. Parameters: Name Type Description Default database_url str URL specifying the connection to the database. '' Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def __init__ ( self , database_url : str = \"\" ) -> None : \"\"\"Initialize the repository attributes. Args: database_url: URL specifying the connection to the database. \"\"\" self . database_url = database_url","title":"__init__()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" raise NotImplementedError","title":"add()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"all()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" raise NotImplementedError","title":"apply_migrations()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" raise NotImplementedError","title":"commit()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. \"\"\" raise NotImplementedError","title":"delete()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference_adapters/#repository_pattern.adapters.AbstractRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/__init__.py @abc . abstractmethod def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" raise NotImplementedError","title":"search()"},{"location":"reference_adapters/#repository_pattern.adapters.fake","text":"Store the fake repository implementation.","title":"fake"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository","text":"Implement the repository pattern using a memory dictionary.","title":"FakeRepository"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.__init__","text":"Initialize the repository attributes. Source code in repository_pattern/adapters/fake.py def __init__ ( self , database_url : str = \"\" , ** data : Any ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( ** data ) if database_url == \"wrong_database_url\" : raise ConnectionError ( f \"There is no database file: { database_url } \" )","title":"__init__()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/fake.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] except KeyError : self . new_entities [ type ( entity )] = {} self . new_entities [ type ( entity )][ entity . id_ ] = entity","title":"add()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" try : return sorted ( entity for entity_id , entity in self . entities [ entity_model ] . items () ) except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) from error","title":"all()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/fake.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\"","title":"apply_migrations()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/fake.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" for entity_model , entities in self . new_entities . items (): self . entities [ entity_model ] = entities self . new_entities = {}","title":"commit()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" if self . new_entities == {}: self . new_entities = copy . deepcopy ( self . entities . copy ()) try : self . new_entities [ type ( entity )] . pop ( entity . id_ , None ) except KeyError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error","title":"delete()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/fake.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" try : entity = self . entities [ entity_model ][ entity_id ] except KeyError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s \" f \"with id { entity_id } in the repository.\" ) from error return entity","title":"get()"},{"location":"reference_adapters/#repository_pattern.adapters.fake.FakeRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/fake.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" all_entities = self . all ( entity_model ) entities_dict = { entity . id_ : entity for entity in all_entities } entity_attributes = { entity . id_ : entity . dict () for entity in all_entities } error_msg = ( f \"There are no { entity_model . __name__ } s that match \" f \"the search filter { fields } \" ) for key , value in fields . items (): # Get entities that have the value `value` entities_with_value = entity_attributes | grep ( value ) matching_entity_attributes = {} try : entities_with_value [ \"matched_values\" ] except KeyError as error : raise EntityNotFoundError ( error_msg ) from error for path in entities_with_value [ \"matched_values\" ]: entity_id = re . sub ( r \"root\\[(.*?)\\]\\[.*\" , r \"\\1\" , path ) # Convert int ids from str to int try : entity_id = int ( entity_id ) except ValueError : entity_id = re . sub ( r \"'(.*)'\" , r \"\\1\" , entity_id ) # Add the entity to the matching ones only if the value is of the # attribute `key`. if re . match ( re . compile ( fr \"root\\['? { entity_id } '?\\]\\[' { key } '\\]\" ), path ): matching_entity_attributes [ entity_id ] = extract ( entity_attributes , f \"root[ { entity_id } ]\" ) entity_attributes = matching_entity_attributes entities = [ entities_dict [ key ] for key in entity_attributes . keys ()] if len ( entities ) == 0 : raise EntityNotFoundError ( error_msg ) return entities","title":"search()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika","text":"Define the Pypika Repository.","title":"pypika"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository","text":"Implement the repository pattern using the Pypika query builder.","title":"PypikaRepository"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.__init__","text":"Initialize the repository attributes. Source code in repository_pattern/adapters/pypika.py def __init__ ( self , database_url : str ) -> None : \"\"\"Initialize the repository attributes.\"\"\" super () . __init__ ( database_url ) database_file = database_url . replace ( \"sqlite:///\" , \"\" ) if not os . path . isfile ( database_file ): raise ConnectionError ( f \"There is no database file: { database_file } \" ) self . connection = sqlite3 . connect ( database_file ) self . cursor = self . connection . cursor ()","title":"__init__()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.add","text":"Append an entity to the repository. Parameters: Name Type Description Default entity Entity Entity to add to the repository. required Source code in repository_pattern/adapters/pypika.py def add ( self , entity : Entity ) -> None : \"\"\"Append an entity to the repository. Args: entity: Entity to add to the repository. \"\"\" table = self . _table ( entity ) columns = list ( entity . dict () . keys ()) columns [ columns . index ( \"id_\" )] = \"id\" values = [ value for key , value in entity . dict () . items ()] query = Query . into ( table ) . columns ( tuple ( columns )) . insert ( tuple ( values )) self . _execute ( query )","title":"add()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.all","text":"Obtain all the entities of a type from the repository. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity objects to obtain. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def all ( self , entity_model : Type [ Entity ]) -> List [ Entity ]: \"\"\"Obtain all the entities of a type from the repository. Args: entity_model: Type of entity objects to obtain. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s entities in the repository\" ) return entities","title":"all()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.apply_migrations","text":"Run the migrations of the repository schema. Parameters: Name Type Description Default migrations_directory str path to the directory containing the migration scripts. required Source code in repository_pattern/adapters/pypika.py def apply_migrations ( self , migrations_directory : str ) -> None : \"\"\"Run the migrations of the repository schema. Args: migrations_directory: path to the directory containing the migration scripts. \"\"\" backend = get_backend ( self . database_url ) migrations = read_migrations ( migrations_directory ) with backend . lock (): log . info ( \"Running database migrations\" ) try : backend . apply_migrations ( backend . to_apply ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error running database migrations\" ) log . error ( error ) log . debug ( \"Rolling back the database migrations\" ) try : backend . rollback_migrations ( backend . to_rollback ( migrations )) except Exception as error : # noqa: W0703 # We need to add tests for this function and use a less generic # exception log . error ( \"Error rolling back database migrations\" ) log . error ( error ) raise error log . debug ( \"Complete running database migrations\" )","title":"apply_migrations()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.commit","text":"Persist the changes into the repository. Source code in repository_pattern/adapters/pypika.py def commit ( self ) -> None : \"\"\"Persist the changes into the repository.\"\"\" self . connection . commit ()","title":"commit()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.delete","text":"Delete an entity from the repository. Parameters: Name Type Description Default entity Entity Entity to remove from the repository. required Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def delete ( self , entity : Entity ) -> None : \"\"\"Delete an entity from the repository. Args: entity: Entity to remove from the repository. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table ( entity ) try : self . get ( type ( entity ), entity . id_ ) except EntityNotFoundError as error : raise EntityNotFoundError ( f \"Unable to delete entity { entity } because it's not in the repository\" ) from error query = Query . from_ ( table ) . delete () . where ( table . id == entity . id_ ) self . _execute ( query )","title":"delete()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.get","text":"Obtain an entity from the repository by it's ID. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required entity_id Union[str, int] ID of the entity object to obtain. required Returns: Type Description Entity Exceptions: Type Description EntityNotFoundError If the entity is not found. Source code in repository_pattern/adapters/pypika.py def get ( self , entity_model : Type [ Entity ], entity_id : Union [ str , int ]) -> Entity : \"\"\"Obtain an entity from the repository by it's ID. Args: entity_model: Type of entity object to obtain. entity_id: ID of the entity object to obtain. Returns: entity: Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entity is not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) . where ( table . id == entity_id ) try : return self . _build_entities ( entity_model , query )[ 0 ] except IndexError as error : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s with id { entity_id } in the\" \" repository.\" ) from error","title":"get()"},{"location":"reference_adapters/#repository_pattern.adapters.pypika.PypikaRepository.search","text":"Obtain the entities whose attributes match one or several conditions. Parameters: Name Type Description Default entity_model Type[repository_pattern.model.Entity] Type of entity object to obtain. required fields Dict[str, Union[str, int]] Dictionary with the {key}:{value} to search. required Returns: Type Description List[repository_pattern.model.Entity] Exceptions: Type Description EntityNotFoundError If the entities are not found. Source code in repository_pattern/adapters/pypika.py def search ( self , entity_model : Type [ Entity ], fields : Dict [ str , Union [ str , int ]] ) -> List [ Entity ]: \"\"\"Obtain the entities whose attributes match one or several conditions. Args: entity_model: Type of entity object to obtain. fields: Dictionary with the {key}:{value} to search. Returns: entities: List of Entity object that matches the search criteria. Raises: EntityNotFoundError: If the entities are not found. \"\"\" table = self . _table_model ( entity_model ) query = Query . from_ ( table ) . select ( \"*\" ) for key , value in fields . items (): if key == \"id_\" : key = \"id\" query = query . where ( getattr ( table , key ) == value ) entities = self . _build_entities ( entity_model , query ) if len ( entities ) == 0 : raise EntityNotFoundError ( f \"There are no { entity_model . __name__ } s that match the search filter\" f \" { fields } \" ) return entities","title":"search()"},{"location":"reference_exceptions/","text":"\u00b6 Module to store the repository-pattern exceptions. EntityNotFoundError \u00b6 Raised when the search or retrieve of an entity fails.","title":"Exceptions"},{"location":"reference_exceptions/#repository_pattern.exceptions","text":"Module to store the repository-pattern exceptions.","title":"repository_pattern.exceptions"},{"location":"reference_exceptions/#repository_pattern.exceptions.EntityNotFoundError","text":"Raised when the search or retrieve of an entity fails.","title":"EntityNotFoundError"},{"location":"reference_models/","text":"\u00b6 Module to store the common business model of all entities. Entity pydantic-model \u00b6 Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ > other . id_ # type: ignore __hash__ ( self ) special \u00b6 Create an unique hash of the class object. Source code in repository_pattern/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ ) __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ < other . id_ # type: ignore","title":"Models"},{"location":"reference_models/#repository_pattern.model","text":"Module to store the common business model of all entities.","title":"repository_pattern.model"},{"location":"reference_models/#repository_pattern.model.Entity","text":"Model of any object no defined by it's attributes whom instead has an identity. Unlike value objects, they have identity equality . We can change their values, and they are still recognizably the same thing.","title":"Entity"},{"location":"reference_models/#repository_pattern.model.Entity.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __gt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ > other . id_ # type: ignore","title":"__gt__()"},{"location":"reference_models/#repository_pattern.model.Entity.__hash__","text":"Create an unique hash of the class object. Source code in repository_pattern/model.py def __hash__ ( self ) -> int : \"\"\"Create an unique hash of the class object.\"\"\" return hash ( self . id_ )","title":"__hash__()"},{"location":"reference_models/#repository_pattern.model.Entity.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Entity Entity to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in repository_pattern/model.py def __lt__ ( self , other : \"Entity\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Entity to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" if not isinstance ( other . id_ , type ( self . id_ )): raise TypeError ( f \" { self } and { other } have incompatible ID types\" ) return self . id_ < other . id_ # type: ignore","title":"__lt__()"},{"location":"repositories/","text":"","title":"Repositories"}]}